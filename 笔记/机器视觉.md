[TOC]



# 机器视觉

## c#				

### 一、项目结构&&基础知识

#### 1.程序集信息

​		程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元。程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是.NET 应用程序的构建基块。
程序集具有以下属性：

- 程序集以 .exe 或 .dll 文件的形式实现。
- 对于面向 .NET Framework 的库，可通过将程序集放入全局程序集缓存 (GAC)，在应用程序之间共享程序集。
- 只有在需要使用时才会将程序集加载到内存中。如果未使用程序集，则不加载。
- 可以使用反射，以编程方式获取程序集的相关信息。
- 一个项目在编译后就是一个程序集。

#### 2.引用 

​		`using`关键字用于引入命名空间，也可以引入自己声明的命名空间（`using System.命名空间名称`）。

#### 3.App.config配置文件

​		`App.config`是一个应用程序配置文件，它是一个标准的XML文件这个文件可以包含一些在程序中需要使用的链接、地址等常量以及项目的配置信息，项目需要使用的特点数据信息等。开发人员可以使用配置文件来设置这些值，后期只需要更改配置文件中的配置，而不必重编译应用程序。

​		获取配置文件信息：

1.  在引用中导入Configuration
2. 引入Configuration模块
3. 使用ConfigurationManager管理程序配置的功能类 

```c#
using System.Configuration;
namespace ZhiYou_226_8_Day1_1
{  
    internal class Program
    {
        static void Main(string[] args)
        {

            //ConfigurationManager 用于管理程序配置的功能类
            string NameStr =   ConfigurationManager.AppSettings["Name"].ToString();
            Console.WriteLine(NameStr);
            string NameStr1 = ConfigurationManager.AppSettings["MyConfigString"].ToString();
            Console.WriteLine(NameStr1);
            //调用静态字段
            Console.WriteLine(AppSettingConfig.resultValue1); 
            Console.ReadKey();
        }
    }
    /// <summary>
    /// 静态类AppSettingConfig
    /// </summary>
    internal static class AppSettingConfig
    {
        //静态字段
        public static string resultValue1 = ConfigurationManager.AppSettings["Name123"].ToString();

    }
}

```

#### 4.程序入口类

​		在C#项目中，`Program.cs`文件通常是程序的入口点。这个文件中包含一个`Main`方法，它是所有C#程序的入口点。当你运行一个C#程序时，它会首先执行`Main`方法。**入口文件 --> 入口类 -->入口函数**

4.1**入口函数的作用：**

1. 启动程序：当C#项目运行时，会先执行**Main**方法，执行这个函数就是执行应用程序。
2. 组织代码：**Main**方法可以将零散的代码组织在一起，使代码更具结构性和可读性。它为整个应用程序提供了一个清晰的起点。
3. 处理命令行参数：**Main**方法的参数是一个字符串数组（通常用于接受命令行参数），这个参数可以包含任意数量的命令行输入参数。

#### 5.解决方案和项目

​		1.解决方案是一个或多个项目的集合。

​		2.解决方案并不是**答案**，他只是一个**容器**，用于包含一个或多个相关项目，以及生成信息、VS窗口设置和不与特定项目关联的任何杂项文件。

​		3.解决方案由格式唯一的文本文件（.sln）描述；不应对其进行手动编辑。

#### 6.debug和release

​		1.debug调试 用来运行程序 观察程序执行过程 排查程序错误 不作为正式发布使用 可以使用断点调试功能

​		2.release发布 把调试好的程序 通过relase编译 程序更加轻量 ,并做了优化

​		3.断点调试   当需要对程序的执行过程进行逐步观察时（或者在排错时）使用断点调试

#### 7.三种注释

​		1.单行注释 //

​		2.多行注释  /**/

​		3.XML文档注释

```C#
/// <summary>
/// 管理层的工资
/// </summary>
/// <param name="money">工资</param>
/// <param name="fh">分红</param>
/// <returns></returns>
public double Calculation(double money) 
{ 
    int fh = 10000; 
    return money + fh; 
}
```

#### 8.命名空间和类

​		命名空间主要用于将项目中的代码分组，以避免命名冲突。命名空间可以包含函数、类、变量等。

​		类是一种数据类型，是结构的扩展概念，可以包含数据成员和函数成员。类是面向对象编程的基础，他定义了一种新的数据类型，你可以创建该类型的对象。

​		命名空间主要用于组织代码和避免命名冲突，而类则用于定义对象的行为和属性。

​		同一命名空间中不能定义相同名字的类，可通过定义不同的命名空间来保存相同名字的类，一个项目中可以定义多个相同名字的命名空间，但是只能代表一个。

#### 9.命名规范

​		1.必须以字母、下划线或@开头。

​		2.不可以包含任何嵌入的空格或符号，比如? - +! # % ^ & * ( ) [ ] { } . ; : " ' / \。

​		3.不能是C#中的关键字、保留字。

​		4.区分大小写，myProject和MyProject是不同的两个命名。

​		5.命名要遵循大小驼峰，大驼峰一般用于命名空间或类的命名，小驼峰用于变量或常量。

​		6.不能用C#的类库名称相同。

#### 10.WriteLine、Write、ReadLine和Read（Console）

​		WriteLine和Write用于控制台输出

​		WriteLine可输出空字符串，Write不可以；WriteLine可换行，Write不可以。



​		ReadLine和Read用于获取控制台输入字符（暂停当前程序，按回车后继续执行并返回用户输入内容）

​		ReadLine读取多字符，Read读取的是第一个字符所对应的ASCll码

### 二、数据类型

#### 1.值类型

**值类型** 的变量直接包含其值，这一位置这些数据类型的变量直接包含值。

当你将一个值类型的变量从一个方法传递给另一个方法时，系统会在另一个方法中创建一个变量的副本。两个方法中的变量修改时不会相互影响。

值类型包括：

| 类型    | 描述                               | 范围                                                         | 默认值 |
| :------ | ---------------------------------- | ------------------------------------------------------------ | ------ |
| bool    | 布尔值                             | True、False                                                  | False  |
| byte    | 8位无符号整数                      | 0到255                                                       | 0      |
| sbyte   | 8位有符号整数                      | -128到127                                                    | 0      |
| char    | 16位Unicode字符（单字符类型）      | U+0000到U+ffff                                               | '\0'   |
| decimal | 128位精确的十进制值，28-29有效位数 | <img src="D:\A_material\MachineVision\笔记\images\decimal.png" style="zoom:100%;" /> | 0.0M   |
| double  | 64位双进度浮点型                   | <img src="D:\A_material\MachineVision\笔记\images\double.png" style="zoom:100%;" /> | 0.0D   |
| float   | 32位单精度浮点型                   | <img src="D:\A_material\MachineVision\笔记\images\float.png" style="zoom:100%;" /> | 0.0F   |
| int     | 32位有符号整数                     | -2,147,483,648 到 2,147,483,647                              | 0      |
| uint    | 32位无符号整数类型                 | 0 到 4,294,967,295                                           | 0      |
| long    | 64位有符号整数类型                 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      | 0L     |
| ulong   | 64 位无符号整数类型                | 0 到 18,446,744,073,709,551,615                              | 0      |
| short   | 16 位有符号整数类型                | -32,768 到 32,767                                            | 0      |
| ushort  | 16 位无符号整数类型                | 0 到 65,535                                                  | 0      |

#### 2.引用类型

与值类型不同，**引用类型**不直接存储其值。相反它存储的是值被存储的地址。话句话说，引用类型包含指向另一个存储数据的内存位置的指针。

当你将一个引用类型的变量从一个方法传递给另一个方法时，它不会创建一个新的副本；相反，它会传递变量的地址所以，如果我们在一个方法中改变了一个变量的值，它也会在调用方法中反映出来。一方修改，另一方也会修改。

##### 2.1 对象类型（Object）

**对象（Object）类型** 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进 行类型转换。

当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。

```c#
int val = 1;
object obj = val;  // 装箱操作
object obj = 1;  // 装箱操作
int val = (int)obj;  // 拆箱操作
```

##### 2.2 API

```c#
1. Equals(Object obj)：判断当前对象是否等于另一个对象。
    object obj1 = "Hello";
    object obj2 = "Hello";
    Console.WriteLine(obj1.Equals(obj2));  // 输出：True

2. GetHashCode()：作为默认的哈希函数，返回当前对象的哈希代码。
    object obj = "Hello";
    Console.WriteLine(obj.GetHashCode());  // 输出：某个整数，这个整数是字符串"Hello"的哈希代码

3. GetType()：获取当前实例的Type。
    object obj = "Hello";
    Console.WriteLine(obj.GetType());  // 输出：System.String

4. ToString()：返回一个表示当前对象的字符串。
    object obj = 123;
    Console.WriteLine(obj.ToString());  // 输出：123

5. ReferenceEquals(Object objA, Object objB)：确定指定的Object实例是否是同一个实例。
    object obj1 = new object();
    object obj2 = obj1;
    object obj3 = new object();
    Console.WriteLine(object.ReferenceEquals(obj1, obj2));  // 输出：True
    Console.WriteLine(object.ReferenceEquals(obj1, obj3));  // 输出：False
```



2.2、动态类型（Dynamic）

在C#中，**dynamic类型**是.NET 4.0引入的一个新特性，它允许你在编译时忽略类型检查，而将类型检查推迟到运行时。

当你声明一个变量为dynamic类型时，你可以对它进行任何操作，编译器都不会进行类型检查。这意味着你可以在运行时动态地改变变量的类型。例如：

```c#
dynamic x = 10;
x = "Hello, world!";
```

在这个例子中，x首先被赋值为一个整数，然后又被赋值为一个字符串。这在编译时是完全合法的，因为x是dynamic类型。

然而，如果你在运行时对一个dynamic类型的变量进行了不合法的操作，比如调用了不存在的方法，那么会在运行时抛出异常。

dynamic类型在处理一些动态语言的交互、反射等场景时非常有用。但是，由于它会使得类型检查推迟到运行时，因此可能会增加运行时错误的风险，所以在使用时需要谨慎。

2.2.1 API

```c#
dynamic x = "hello";
Console.WriteLine(x.Length);  // 输出：5

x = 10;
Console.WriteLine(x + 20);  // 输出：30
```



##### 2.3 字符串类型（string）

**字符串（String）类型** 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。

```c#
C# string 字符串的前面可以加 @（称作"逐字字符串"）将转义字符（\）当作普通字符对待，比如：
string str = @"C:\Windows";
          ===
string str = "C:\\Windows";

@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。
string str = @"<script type=""text/javascript"">
    <!--
    -->
</script>";

 //方式1 字面量创建字符串
 string str3 = "abc";
 string str4 = @"abc";
 //方式2  通过单字符数组创建字符串
 char[] charArray = new char[5] { 'a', 'b', 'c', 'd', 'f' };
 string str5 = new string(charArray);
```

###### 2.3.1 属性&&API

```c#
属性：
 1、Length：获取字符串的长度
	string str = "Hello, World!";
	int length = str.Length; // 获取字符串长度

 2、Chars：返回指定索引的字符（也可以直接使用str[0]返回指定索引字符）
	char firstChar = str.Chars[0]; // 获取字符串的第一个字符，结果是 'H'
	char fifthChar = str.Chars[4]; // 获取字符串的第五个字符，结果是 'o'

 3、IsNullOrEmpty：检查字符串是否为空或者null
	string str1 = null;
	string str2 = "";
	string str3 = "Hello, World!";

	bool isNullOrEmpty1 = string.IsNullOrEmpty(str1); // true，因为字符串为 null
	bool isNullOrEmpty2 = string.IsNullOrEmpty(str2); // true，因为字符串为空
	bool isNullOrEmpty3 = string.IsNullOrEmpty(str3); // false，因为字符串不为空

 4、IsNullOrWhiteSpace：检查字符串是否为空、null或者仅包含空白字符
	string str1 = null;
	string str2 = "";
	string str3 = "   "; // 包含多个空白字符
	string str4 = "Hello, World!";

	bool isNullOrWhiteSpace1 = string.IsNullOrWhiteSpace(str1); // true，因为字符串为 null
	bool isNullOrWhiteSpace2 = string.IsNullOrWhiteSpace(str2); // true，因为字符串为空
	bool isNullOrWhiteSpace3 = string.IsNullOrWhiteSpace(str3); // true，因为字符串只包含空白字符
	bool isNullOrWhiteSpace4 = string.IsNullOrWhiteSpace(str4); // false，因为字符串不为空且包含非空白字符

```

```C#
API：
 1、Concat()：将多个字符串拼接成一个新的字符串。
    string str1 = "Hello";
	string str2 = "World";
	string result = string.Concat(str1, ", ", str2);

 2、ToUpper()和ToLower()：字符串大小写转换
    string upper = str.ToUpper(); // 转为大写
	string lower = str.ToLower(); // 转为小写

 3、Trim()：去除字符串两端的空白字符
    string str = "   Hello   ";
	string trimmed = str.Trim(); // 去除两端的空白字符

 4、Substring()：从字符串中提取指定索引的字符
    string str = "Hello, World!";
    string subStr = str.Substring(7, 5); // 提取从索引7开始的5个字符，结果是 "World"

 5、StartsWith()和EndWith()：检查字符串是否以特定前缀开头或后缀结尾
    string str = "Hello, World!";
	bool startsWithHello = str.StartsWith("Hello"); // 检查是否以 "Hello" 开头
	bool endsWithWorld = str.EndsWith("World!"); // 检查是否以 "World!" 结尾

 6、Replace()：替换字符串中的字符或子字符串
    string str = "Hello, World!";
	string replaced = str.Replace("Hello", "Hi"); // 替换 "Hello" 为 "Hi"

 7、Split()：根据指定字符将字符串拆分为子字符串数组。
    string str = "apple,banana,cherry";
	string[] fruits = str.Split(','); // 拆分为数组 ["apple", "banana", "cherry"]

 8、IndexOf()和LastIndexOf()：查找字符或子字符串在字符串中的位置。
    string str = "Hello, World!";
	int indexOfComma = str.IndexOf(','); // 查找逗号的位置，结果是 5
	int lastIndexOfL = str.LastIndexOf('l'); // 查找最后一个小写字母 "l" 的位置，结果是 10
 9、判断一个字符串是否以特定的前缀开头
    string input7 = Console.ReadLine();
    Console.WriteLine(input7.StartsWith(","));
```

###### 2.3.2 转义字符

```c#
 char q = '\n';  
 string r = "今天\n不好";
 string s = @"今天\n不好";  // 添加@引号中的转义字符失效 变为单字符
 bool t = r == s; // false
 string u = "D:\\A_material\\前端\\面试";
 string string2 = @"n1212121qeqeqn1212121qeqn121212
1qeqeqn1212121qen1212121qeqeqn1212121qeqeq尼qeq尼eq尼"; // 多行字符串  引号前面添加@字符串内字符可以随意换行
 string v = "\\\\\\\\" 输出为 \\\\    其中两个\\为一对 前一个将后一个转义为普通字符
     
 补充日期类型
  DateTime dateTimeValue = DateTime.Now;
  Console.WriteLine(dateTimeValue);
```

###### 2.3.3 可变字符串和不可变字符串

不可变字符串：

- 一旦创建，他们的内容就不能被修改。
- 在C#中 **System.string** 类是不可变的，这意味着一旦你创建一个字符串对象，它的内容就不能更改。
- 当对不可变字符串进行操作时，实际上会创建一个全新的字符串对象，而原始字符串对象保持不变。
- 不可变字符串具有线程安全性，因为他们不会被更改，所以多个线程可以同时访问它们而不会导致竞态条件。
- 不可变字符串的优点是安全性和性能稳定性，但在频繁修改字符串时会产生性能开销。

```c#
	string s1 = "Hello";
	string s2 = s1 + " World"; // 创建一个新的字符串对象
```

可变字符串：

- 可变字符串允许在同一对象上进行修改，而不必创建新的字符串对象。
- 在C#中，**System.Text.StringBuilder**类提供了可变字符串的支持。
- 可变字符串通常用于需要频繁修改字符串内容的情况，以提高性能。
- 可变字符串不具备不可变字符串的线程安全性，因此在多线程环境下使用时需要谨慎处理。

```c#
	StringBuilder sb = new StringBuilder("Hello");
	sb.Append(" World"); // 修改现有可变字符串，无需创建新对象
```

#### 3.变量和常量

##### 3.1变量

​		含义：用来存储特定的数据类型。

```C#
	使用方法：变量格式 变量名 = 变量值;
 				int  num = 100;
```

​		特点：1.同一变量名不能重复声明，同意作用域变量名不可重复。

​					2.同一变量名重复赋值以最后一次赋值为准。

​					3.变量只有赋值后才能使用，否则报错。

##### 3.2常量

​		含义：用来存储特定且不会改变的数据类型。

​		const在声明常量时必须给其赋值，readOnly可以先声明后赋值。

​		常量命名规范：建议全部单词大写，可用下划线 - 隔开 例：const int CONST_INT_NUMBER = 10;

```c#
	分类：1.值类型常量：const int MY_INT = 10;
		 2.字符串常量：const string MY_STRING = "Hello, World!";
		 3.readOnly：public readonly int MyReadonlyField = 10;  用来声明只读字段，只读字段只能在声明时或者在构造函数中被赋值。
		namespace Day3_1 {
             internal class Program {
                 readonly static int ReadOnlyInt = 100;
                 readonly int ReadOnlyInt1;
             }
             internal Program(int value) {
                 ReadOnlyInt1 = value;
             }
             
             static void Main(string[] args) {
                 Program test = new Program(109);
                 Console.WriteLine(test.ReadOnlyInt1);  // 109
             }
        }
```



#### 4.数据类型转换

```C#
	 int intNumber = 1;
	 //int转long     小区间转大区间（隐式类型转换）
	 long longNumber = intNumber;

	 //long转int     大区间转小区间（显式类型转换）
	 int intNumber1 = (int)longNumber;

	 //int转float    大区间转小区间（隐式类型转换）
	 float floatNumber1 = intNumber;

	 //float转long   
	 float floatNumber2 = 1.1f;
 	 long longNumber1 = (long)floatNumber2;
```

#### 5.值类型转换

```c#
	1.Parse()适用于string转换成值类型
    2.int 代表System.int32结构体 Parse属性结构体中的方法
		string strNumber = "123";
		string strNumber1 = "123啊";
		int intStrNumber = int.Parse(strNumber);
		int.Parse(strNumber);     		  // 123
		System.Int32.Parse(strNumber);	  // 123
		Console.WriteLine(intStrNumber);  // 123
        Console.WriteLine(intStrNumber.GetType()); //获取转换后的类型
	3.解决非数字转换的异常问题 使用 TryParse()转换成返回true 失败返回false 
        int ab;
		bool isSuccess = int.TryParse(strNumber1, out ab); // ab为转换后的结果
		Console.WriteLine(ab);   若isSuccess为false则转换失败，转换后的结果为0。
    4.Convert 适合各种类型相互转换
         string converStr = "123";
         int converInt = 123;
         bool converBool = true;
         int converInt1 = Convert.ToInt32(converStr); // 字符串转int值类型
         long converLong = Convert.ToInt32(converInt1); // int转long 值类型相互转换
         string converInt2 = Convert.ToString(converBool); // 布尔转字符串
	5.toString() 任何类型转string
         int num1 = 100;
		 bool bool1 = false;
		 float float1 = 1.1f;

		 Console.WriteLine(num1.ToString());   // 100
		 Console.WriteLine(bool1.ToString());  // False
		 Console.WriteLine(float1.ToString()); // 1.1
```

#### 6.算术运算符

```c#
		// +  -  *  /  %数字类型大类型和小类型结合 结果默认为大类型结果
		string strNumber = "123";
		string strNumber1 = "123";
		int intNumber = 123;
		Console.WriteLine(intNumber + strNumber1);  // 123123

		long longNumber = 111;
		ulong uLongNumber = 111;
		Console.WriteLine(longNumber + uLongNumber); // 错误代码不可执行，两个类型相加会出现二义性错误，可以手动将其中一个类型显示的转换为另一个类型在进行运算
		
		非数字类型不可以直接使用 -
        单字符使用 - 时会隐式转换为数字类型
            
        ++ -- 变量自身自增或自减1
		num++ 后置递增 先返回原来的num，然后+1
        ++num 前置递增 直接返回+1后的num
			int number = 0;
			int result = number++ * 2; // result为0，因为先返回number的值（0），然后再将number增加1

			int number = 0;
			int result = ++number * 2; // result为2，因为先将number增加1，然后返回新的number的值（1），最后乘以2
```

​			二义性错误：在C#中，当编译器无法确定应该使用哪个重载版本的方法或运算符时，就会出现二义性错误。这通常发生在你尝试对两种不同类型的操作数执行操作，而编译器找到了多个可能的匹配的方法或运算符。**longNumber**是**long**类型，**uLongNumber**是**ulong**类型。当你尝试将它们相加时，编译器无法确定应该将它们都转换为**long**还是都转换为**ulong**。因此，编译器报告了二义性错误。

#### 7.Null    ?    ??

```C#
		1.表示不引用任何对象的空引用,没有创建内存空间,存放的是空引用指针；
        2.Null类型是System.Nullable < T > 这个struct的类型
        3.值类型不能直接赋值null 引用类型可以直接赋值null
            System.Nullable<int> a = null;
            int? a1 = null;
            
         null和字符串空值和字符串空格的区别
         1.null是没有创建内存空间,
         2.字符串空值  为"" 或者string.Empty  实际上都会分配空间；
         3.字符串空格 "    "  会分配空间 空格也是ACSII  对应的符号
            
		 双问号 ??（合并运算符）
		 作用：
		 可空类型给不可空类型 赋值时 使用
		 用于判断一个变量在为 null 的时候返回一个指定的值
```

#### 8.数组

```C#
		    //不可变数组 （一维数组）
            //含义：不可变数组是一个存储相同类型元素的固定大小的顺序集合  是一种数据类型	
            //特点：数组属于引用类型，数组只能包含类型相同的元素，数组通过下标（索引值）标记元素   从左到右 从0 依次递增1

		初始化数组中的元素的方式
		数据类型[] 数组名 = {值 1, 值 2, …}
		数据类型[] 数组名 = new 数据类型[长度]{值 1，值 2,…}
		数据类型[] 数组名 = new 数据类型[长度可忽略]{值 1，值 2,…}
		数据类型[] 数组名 = new 数据类型[长度];

		// 声明一个一维数组
		int[] array1 = new int[5];

		// 声明并初始化一个一维数组
		int[] array2 = { 1, 2, 3, 4, 5, 6 };

		// 声明一个二维数组
		int[,] multiDimensionalArray1 = new int[2, 3];

		// 声明并初始化一个二维数组
		int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };

		// 声明一个交错数组
		int[][] jaggedArray = new int[6][];

		// 设置交错数组的第一个数组的值
		jaggedArray[0] = new int[4] { 1, 2, 3, 4 };

```

##### 8.1 属性&&API	

```C#
属性：	int[] array = { 1, 2, 3, 4, 5 };
	1.IsFixedSize:获取一个值，该值指示数组是否带有固定大小。
        Console.WriteLine("IsFixedSize: " + array.IsFixedSize);

    2.IsReadOnly：获取一个值，该值指示数组是否只读。
        Console.WriteLine("IsReadOnly: " + array.IsReadOnly);

 	3.Length：获取一个32位整数，该值表示所有维度的数组中的元素总数。
        Console.WriteLine("Length: " + array.Length);

    4.LongLength：获取一个64位整数，该值表示所有维度的数组中的元素总数。
        Console.WriteLine("LongLength: " + array.LongLength);

    5.Rank：获取数组的秩（维度）。
        Console.WriteLine("Rank: " + array.Rank);

API:
	1.GetValue：获取一维数组中指定位置的值。
        int[] array = { 1, 2, 3, 4, 5 };
		int firstElement = (int)array.GetValue(0);
        
    2.SetValue：给一维数组中指定位置的元素设置值。
		array.SetValue(100, 0);
        
    3.IndexOf：搜索指定的对象，返回整个一维数组中第一次出现的索引。
        int[] array = { 1, 2, 3, 4, 5 };
		int index = Array.IndexOf(array, 3);
        
    4.Reverse：逆转整个一维数组中元素的顺序。
        int[] array = { 1, 2, 3, 4, 5 };
		Array.Reverse(array);
        
    5.GetLength：获取一个32位整数，该值表示指定维度的数组中的元素总数
        int[,] array = { { 1, 2 }, { 3, 4 }, { 5, 6 } };
		int rows = array.GetLength(0);
        
    6.GetLongLength：获取一个64位整数，该值表示指定维度的数组中的元素总数。
		long longRows = array.GetLongLength(0);
        
    7.GetLowerBound：获取数组中指定维度的下界。
        int[] array = { 1, 2, 3, 4, 5 };
		int lowerBound = array.GetLowerBound(0);
        
    8.GetUpperBound：获取数组中指定维度的上界。
		int upperBound = array.GetUpperBound(0);
        
    9.Clear：根据元素的类型，设置数组中某个范围的元素为零、为false或者为null。
        int[] array = { 1, 2, 3, 4, 5 };
		Array.Clear(array, 0, array.Length);

    10.Copy：从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。
        int[] array1 = { 1, 2, 3, 4, 5 };
		int[] array2 = new int[5];		
		int[] array3 = new int[5];
		Array.Copy(array1, array3, array1.Length); // 使用Copy方法
        
    11.CopyTo：从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。
      array1.CopyTo(array2, 0); // 使用CopyTo方法  深拷贝
        
    12.Sort：使用数组的每个元素的IComparable（比较）实现来排序整个一维数组中的元素。
        int[] array = { 5, 4, 3, 2, 1 };
		Array.Sort(array);

    13.Exists：检查数组中是否存在满足指定条件的元素。
        int[] array = { 1, 2, 3, 4, 5 };
		int value = 3;
		bool exists = Array.Exists(array, element => element == value);
		if (exists) {
            Console.WriteLine("Element found in array");
        } else {
            onsole.WriteLine("Element not found in array");
        }

```



#### 9.可变参数

​		**params**关键字用于指定方法可以接受可变数量的参数。这些参数必须是一维数组类型，并且必须是方法参数列表的最后一个参数。

- `params`修饰的可变参数数组必须是一维数组。
- 不允许将`params`修饰符与`ref`和`out`修饰符组合起来使用，但是可以分开使用，也就是`params`前一个参数可以定义为`ref`或者`out`。
- 传递到形参`params`中的数据可以是跟`params`类型一致的数组，也可以是任意多个与该`params`类型一致的变量。还可以不发送参数。如果未发送任何参数，则 `params` 列表的长度为零。
- `params`参数必须是参数表的最后一个参数，并且在方法声明中只允许一个 `params` 关键字。
- 若实参是数组则按引用传递，若实参是变量或表达式则按值传递。

```C#
public class MyClass 
{
    public static void UseParams(params int[] list) 
    {
        for (int i = 0; i < list.Length; i++)  
        {  
            Console.Write(list[i] + " ");  
        }  
        Console.WriteLine();  
    }

    public static void UseParams2(params object[] list) 
    {
        for (int i = 0; i < list.Length; i++)  
        {  
            Console.Write(list[i] + " ");  
        }  
        Console.WriteLine();  
    }

    static void Main() 
    {
        // 您可以发送指定类型的以逗号分隔的参数列表。
        UseParams(1, 2, 3, 4);  
        UseParams2(1, 'a', "test");

        // params 参数接受零个或多个参数。
        UseParams2();

        // 可以传递数组参数，只要数组类型与所调用方法的参数类型匹配即可。
        int[] myIntArray = {5, 6, 7, 8, 9};  
        UseParams(myIntArray);

        object[] myObjArray = {2, 'b', "test", "again"};  
        UseParams2(myObjArray);
    }
}

```



#### 10.交错数组

​		数据类型为一维数组的一维数组

```C#
using System;

class MyArray
{
    static void Main(string[] args)
    {
        /* 一个由5个整型数组组成的交错数组 */
        int[][] a = new int[][] {
            new int[] {0, 0},
            new int[] {1, 2},
            new int[] {2, 4},
            new int[] {3, 6},
            new int[] {4, 8}
        };

        int i, j;

        /* 输出数组中每个元素的值 */
        for (i = 0; i < 5; i++)
            for (j = 0; j < 2; j++)
                Console.WriteLine("a[{0}][{1}] = {2}", i, j, a[i][j]);

        Console.ReadKey();
    }
}
```



### 三、循环语句

#### 1.for循环

​		**适用场景：适用于已知循环次数的情况，通常使用计数器控制。**

```C#
		  for (int i = 0; i < n; i++){
              // 循环体
          }

	      for (;;) {  //无限循环
    
          }
```

#### 2.while

​		**适用场景：适用于循环次数不确定，只要条件满足就继续执行的情况。**

```C#
		while (condition) {
            // 循环体
        }
```

#### 3.do-while

​		**适用场景：适用于至少需要执行一次循环体的情况，然后根据条件继续执行。**

```C#
		do {
            // 循环体
        } while (condition);
```

#### 4.foreach

​		**适用场景：适用于遍历集合、数组或其他可枚举对象的情况，无需显式计数器。**

```C#
		foreach (var item in collection) {
            // 循环体
        }
```

#### 5.break&&continue

​		**break：用于在循环中提前终止循环，通常与if语句结合使用。**

​				 	 **适用于需要在满足特定条件时立即退出循环的情况。**

​		**continue：用于跳过当前迭代的循环体中的剩余代码，继续下一次迭代。**

​				    		**适用于在特定条件下跳过某些迭代的情况。**

### 四、修饰符&&函数&&类

#### 1.访问修饰符

​		**internal**：只能在当前程序集中访问。

​		**public**：可以从任何地方访问。

​		**private**：只能在当前类中访问。

​		**protected**：只能在当前类和派生类中访问。

​		**protected internal**：可以在当前程序集或派生类中访问。

​		**private protected**：(C# 7.2+): 只能在当前程序集中的派生类中访问。

#### 2.其他修饰符

​		**static**：表示静态成员，不需要实例化即可访问。

​		**readonly**：表示只读字段，只能在构造函数中或字段初始化时分配值。

​		**const**：表示常量，其值在编译时确定，不可更改。

​		**sealed**：用于类，防止其他类继承它。

​		**abstract**：用于类和方法，表示类为抽象类，方法为抽象方法，不能直接实例化。

​		**virtual**：用于方法，表示方法可以被派生类重写。

​		**override**：用于派生类中的方法，表示重写基类中的虚拟方法。

​		**new**：用于隐藏那个基类侧好难过元，允许在派生类中定义具有相同名称的新成员。

​		**partial**：用于部分类，允许将一个类分成多个文件。

#### 3.访问修饰符的区别

​		**internal**：仅对同一程序集内的类型可见。

​		**public**：对所有类型都可见。

​		**private**：仅对定义该成员的类可见

​		**protected internal**：对同一程序集内和派生类可见。

#### 4.类

##### 		4.1 不同访问权限

```C#
		public static void ConsoleNumberOne() {
            Console.WriteLine(100);
        }

		internal static void ConsoleNumberTwo() {
            Console.WriteLine(1000);
        }

		private static void ConsoleNumberThree() {
            Console.WriteLine(10000);
        }

		protected static void ConsoleNumberFour() {
            Console.WriteLine(10000);
        }
```

##### 		4.2 静态和非静态

```C#
		public static void ProgramMothod() {
            Console.WriteLine("ProgramMothod");
        }

		public void ProgramMothod1() {
            Console.WriteLine("ProgramMothod1");
        }
```

##### 		4.3 有无参数

##### 		4.4 有无返回值

##### 4.5 成员变量（字段）

1. 字段是类型的成员，也称为成员变量，在类中字段也可以叫全局变量，在整个类中可以使用。
2. 字段是定义在类中方法之外的，局部变量是定义在方法内部的。
3. 字段的格式：访问修饰符 数据类型 变量名。
4. 字段都有默认值，值类型默认值为0，引用类型默认值为null，局部变量没有默认值。
5. 字段的类型为值类型和字符串类型，使用时是深拷贝（会克隆），其他的引用类型默认是浅拷贝（不克隆，赋原值）。
6. 字段的访问修饰符。
7. 在一个类中不可重复定义字段，允许定义相同名字的字段或局部变量，调用采用就近原则。
8. 命名规则： _ + 小驼峰 保持和系统框架中的字段名字一致。
9. 字段包含静态和非静态（实例调用）。
10. const定义的常量不能使用static，因为const描述的字段 本质就是包含静态的含义。
11. readonly定义的常亮可以使用static，可以在定义字段时赋值或者在其构造函数中赋值。
12. 一般使用字段时，都使用private，为了内部的字段不暴露给其他类。

​		但是使用private后 字段的灵活消失  ，使用类的成员-属性 来解决 字段灵活性的问题
​		实例字段 随着new对象的创建而创建
​		静态字段 在类加载的时候创建 且创建一次

##### 4.6 属性

​	属性和字段的关系：

1. 属性是类的成员函数
2. 属性是外界访问私有字段的入口
3. 属性的本质就是方法，一个属性可以分别有一个set 和 get方法组成
4. 使用大驼峰命名，一般和对应的私有字段名字保持一致
5. 可为字段添加判断逻辑

##### 4.7 构造函数

1. 本质就是方法。
2. 类创建对象时使用的特殊方法。
3. 类默认存在构造函数 
4. 构造函数的名字一定要和类名相同。
5. 构造函数分为实例构造函数、私有构造函数和静态构造函数。
6. 构造函数没有返回类型，可以带参数。
7. 构造函数自定义时，会覆盖系统默认的，系统默认的功能不能满足要求时自定义构造函数。
8. 实例构造一般使用public。
9. 私有构造函数使用private。不希望其他类创建自身的对象时（没有实例成员时）。
10. 系统会默认自带静态构造函数，在类创建时用来初始化所有的静态成员。
11. 静态构造函数没有访问修饰符，也没有参数。
12. 无参数的实例构造函数可以与静态构造函数共存。尽管参数列表相同，但属于一个类。

##### 4.8 静态类

1. 特点：

- 静态类使用 `static` 修饰符进行声明，例如：`static class MyStaticClass { ... }`。
- 静态类不能被实例化，即不能创建该类的对象。它们的主要目的是提供一个容器来组织和存储静态成员，如静态方法和静态字段。
- 静态类的所有成员都必须是静态的，包括方法和字段。实例成员在静态类中是不允许的。

2. 主要用途：

- 提供一个命名空间内的全局访问点：静态类中的静态成员可以在不创建类的实例的情况下访问。这可以用于提供全局配置、工具函数等。
- 组织相关的静态方法：静态类通常用于组织一组相关的静态方法，这些方法在应用程序中执行相似的操作。
- 避免不必要的实例化：某些情况下，不需要创建类的实例，只需要调用其中的方法，这时使用静态类可以避免不必要的对象实例化。

##### 4.9 继承（Inheritance）

- 继承是一种机制，它允许一个类（子类或派生类）基于另一个类（父类或基类）来创建新的类。
- 子类继承了父类的成员，包括字段、属性、方法等。
- 继承有助于实现代码重用，避免重复编写相似的代码，并构建层次结构，使代码更有层次性。		

​		继承是面向对象编程（OOP）中的一个重要概念，C#也支持继承。在C#中，继承允许你创建一个新的类（子类或派生类），该类可以继承另一个现有类（父类或基类）的成员，如字段、属性、方法和事件。子类继承了父类的特性，并且可以添加自己的成员或覆盖继承的成员。

###### 4.9.1 **基类和派生类**：

- 基类是被继承的类，也称为父类。派生类是继承基类的类，也称为子类。
- 派生类可以继承一个基类的成员，包括字段、属性、方法等。

###### 4.9.2 **语法**：

- 使用冒号 `:` 后跟基类的名称来声明派生类。例如：`class ChildClass : ParentClass`。
- 派生类可以继承所有非私有的基类成员。
- 派生类可以添加自己的成员，包括字段、属性、方法等。
- 派生类可以覆盖（重写）基类的虚拟方法或属性。

###### 4.9.3 **访问修饰符**：

- 成员的访问修饰符（public、protected、private等）控制了它们在派生类中的可见性。
- `public` 成员可以在派生类和外部访问。
- `protected` 成员只能在派生类内部访问。
- `private` 成员只能在基类内部访问。

###### 4.9.4 **重写和隐藏**：

- 派生类可以使用 `override` 关键字重写基类的虚拟方法。
- 如果不使用 `override`，则在派生类中的同名方法将会隐藏基类中的方法，这被称为方法的隐藏。

```C#
	class ParentClass {
        public void Print() {
            Console.WriteLine("This is from the ParentClass");
        }
    }

	class ChildClass : ParentClass {
        public void Display() { 
            Console.WriteLine("This is from the ChildClass");
        }

        public override void Print() {
            Console.WriteLine("This is from the ChildClass (overridden method)");
        }
    }
	在上面的示例中，ChildClass 继承了 ParentClass，并重写了 Print 方法。子类添加了自己的 Display 方法。通过创建 ChildClass 的对象，你可以访问父类的成员以及子类自己的成员。
```

##### 4.10 封装（Encapsulation）

- 封装是将数据和操作数据的方法捆绑在一起的概念。
- 在C#中，你可以使用类来实现封装。类将数据成员（字段）和方法封装在一起，并通过访问修饰符（如 `private`、`public`、`protected`）来控制对数据的访问。
- 封装可以隐藏数据的具体实现细节，同时提供公共接口供其他代码使用，这有助于保护数据的完整性和安全性。

##### 4.11 多态 （Polymorphism）

- 多态是一个对象可以表现出多种不同的形态的能力。
- 在C#中，多态通过方法的重载和重写来实现。方法的多态性允许在不同的上下文中使用相同的方法名称，但具体执行的代码根据调用的对象类型而不同。
- 多态性有助于提高代码的灵活性，允许在运行时决定使用哪个具体的实现。

##### 4.12 重载（Overloading）

- 方法重载是指在同一个类中定义多个具有相同名称但不同参数列表的方法。
- C#编译器会根据调用时提供的参数类型或数量来选择正确的重载方法。
- 方法重载有助于提供不同参数组合的方法，以便更方便地使用相同方法名称。

##### 4.13 重写（Overriding）

- 方法重写是指子类可以提供一个新的实现来覆盖基类中的方法。
- 重写通常与多态性一起使用，它允许子类根据自己的需求重新实现继承的方法。
- 重写的方法必须具有与基类方法相同的名称、参数和返回类型，并使用 `override` 关键字标记。
- 使用关键字 virtual，将父类的方法标记为虚方法（父类允许子类覆盖方法的标签）用 override  关键字，虚方法可以被子类重写。

##### 4.13  base

- base关键字用于从派生类中访问基类的成员；
- 派生类对象调用基类构造函数；
- 调用基类上已被重写的方法；
- 不能从静态方法中使用base关键字，base关键字只能在实例构造函数、实例方法或实例访问器中使用。

```C#
	访问基类成员：
		在派生类中，你可以使用 base 关键字来访问基类的成员，包括字段、属性和方法。
		这是有用的，当派生类和基类有同名成员时，使用 base 可以明确指定要调用基类的成员
	class BaseClass {
        public void Display() {
            Console.WriteLine("This is from the BaseClass");
        }
    }

	class DerivedClass : BaseClass {
        public void Display() {
            Console.WriteLine("This is from the DerivedClass");
        }

    	public void ShowBaseDisplay() {
            base.Display(); // 调用基类的 Display 方法
        }
    }

	调用基类构造函数： 
		在派生类的构造函数中，你可以使用 base 关键字来调用基类的构造函数。
		这是有用的，当你需要执行基类构造函数的初始化操作，然后再执行派生类构造函数的操作。
    using System;
	class Animal {
        public string Name { get; set; }
        public Animal(string name) {
            Name = name;
            Console.WriteLine($"Animal {Name} is born.");
        }
        
        public void Eat() { 
            Console.WriteLine($"{Name} is eating.");
        }
    }

	class Dog : Animal {
        public string Breed { get; set; }
        public Dog(string name, string breed) : base(name) { 
            Breed = breed;
            Console.WriteLine($"Dog {Name} of breed {Breed} is born.");
        }
        
        public void Bark() {
            Console.WriteLine($"{Name} is barking.");
        }
    }

	class Program {
        static void Main(string[] args) {
            Dog myDog = new Dog("Buddy", "Golden Retriever");
            myDog.Eat();
            myDog.Bark();
        }
    }
	在上述示例中，Animal 类和 Dog 类之间建立了继承关系。Dog 类的构造函数使用 base(name) 来调用基类 Animal 的构造函数，以确保 Name 属性在创建 Dog 对象时得到初始化。这样，可以在构造函数中完成一些初始化工作，并确保正确设置属性值。
	在 Main 方法中，我们创建了一个 Dog 对象，并演示了如何访问基类和派生类的成员。这个示例显示了如何使用 base 来调用基类构造函数，以便在继承关系中正确初始化对象。
```

##### 4.14 接口

1. 接口定义了所有类继承接口时应遵循的语法合同。
2. 接口定义了语法合同的"是什么"部分，派生类定义了语法合同的"怎么做"部分。
3. 接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。
4. 成员的定义是派生类的责任。
5. 接口提供了派生类应遵循的标准结构。
6. 接口使得实现接口的类或结构在形式上保持一致。
7. 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。
8. 接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。
9. 抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。
10. 接口使用`interface`关键字声明，它与类的声明类似。接口声明默认是`public`的。

```C#
interface IMyInterface {
    void MethodToImplement();
}
```

##### 4.15  抽象类

​		在C#中，抽象类是一种特殊的类，它使用abstract关键字进行声明。抽象类的主要特性是它不能被实例化，只能被其他类继承。这意味着，如果你有一个抽象类，那么没有任何类可以直接创建这个抽象类的实例。抽象类可以包含抽象方法和非抽象方法。抽象方法是一种特殊的方法，它在抽象类中被声明，但没有具体的实现。抽象方法必须在任何非抽象类（即，继承抽象类的类）中被重写。

```c#
public abstract class AbstractClass
{
    public abstract void AbstractMethod();

    public void NonAbstractMethod()
    {
        // Implementation here...
    }
}

```

​	

​		在这个例子中，**AbstractClass**是一个抽象类，它包含一个抽象方法**AbstractMethod**()和一个非抽象方法**NonAbstractMethod**()。这些方法只能通过实例化继承抽象类的类来访问，而不能通过实例化抽象类本身来访问。

​		抽象类的主要用途是作为其他类的基类。它为派生类提供了一个通用的、标准的基本模板。派生类可以继承抽象类的成员，也可以重写抽象类中的抽象方法。

​		需要注意的是，抽象类除了不能被实例化外，其用法与非抽象类大致相同。此外，抽象类还可以提供一些运行时优化，略微提高抽象类成员的调用速度。

##### 4.16 接口和抽象类的异同

**相同点**：

- [抽象类和接口都是抽象的，不能实例化，需要子类实现其抽象成员](https://zhuanlan.zhihu.com/p/511932063)[4](https://zhuanlan.zhihu.com/p/511932063)。

**不同点**：

1. [**继承**：接口可以被多重实现，抽象类只能被单一继承](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[1](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[3](https://www.cnblogs.com/HomeSapiens/p/17298584.html)[5](https://zhuanlan.zhihu.com/p/463345426)。
2. [**成员实现**：抽象类可以包含已实现的成员，而接口不能包含任何成员的实现](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[1](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[2](https://zhuanlan.zhihu.com/p/357098839)[4](https://zhuanlan.zhihu.com/p/511932063)。
3. [**成员类型**：抽象类可以定义字段、方法、属性、事件、索引器的实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
4. [**访问修饰符**：接口中的成员访问类型默认为公共的，不能有其他的访问修饰符修饰](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
5. [**关键字**：定义的关键字不一样，抽象类需要使用`abstract`，而接口则使用`interface`](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
6. [**回调支持**：接口可以用于支持回调，抽象类不能实现回调](https://www.cnblogs.com/HomeSapiens/p/17298584.html)[3](https://www.cnblogs.com/HomeSapiens/p/17298584.html)。

**使用场景**：

- [如果对象存在多个功能相近且关系紧密的版本，则使用抽象类](https://zhuanlan.zhihu.com/p/357098839)[2](https://zhuanlan.zhihu.com/p/357098839)。
- [如果对象关系不密切，但是若干功能拥有共同的声明，则使用接口](https://zhuanlan.zhihu.com/p/357098839)[2](https://zhuanlan.zhihu.com/p/357098839)。

#### 5.泛型

​		在C#中，泛型（Generic）是一种规范，它允许我们使用占位符来定义类和方法，编译器会在编译时将这些占位符替换为指定的类型。这意味着，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

[使用泛型是一种增强程序功能的技术，具体表现在以下几个方面](https://www.runoob.com/csharp/csharp-generic.html)[2](https://www.runoob.com/csharp/csharp-generic.html)：

- 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。
- 您可以创建泛型集合类。.NET 框架类库在 System.Collections.Generic 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 System.Collections 中的集合类。
- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
- 您可以对泛型类进行约束以访问特定数据类型的方法。
- 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。

```C#
using System;
using System.Collections.Generic;

namespace GenericApplication
{
    public class MyGenericArray<T>
    {
        private T[] array;
        public MyGenericArray(int size)
        {
            array = new T[size + 1];
        }
        public T getItem(int index)
        {
            return array[index];
        }
        public void setItem(int index, T value)
        {
            array[index] = value;
        }
    }

    class Tester
    {
        static void Main(string[] args)
        {
            // 声明一个整型数组
            MyGenericArray<int> intArray = new MyGenericArray<int>(5);
            // 设置值
            for (int c = 0; c < 5; c++)
            {
                intArray.setItem(c, c * 5);
            }
            // 获取值
            for (int c = 0; c < 5; c++)
            {
                Console.Write(intArray.getItem(c) + " ");
            }
            Console.WriteLine();
            // 声明一个字符数组
            MyGenericArray<char> charArray = new MyGenericArray<char>(5);
            // 设置值
            for (int c = 0; c < 5; c++)
            {
                charArray.setItem(c, (char)(c + 97));
            }
            // 获取值
            for (int c = 0; c < 5; c++)
            {
                Console.Write(charArray.getItem(c) + " ");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
当上面的代码被编译和执行时，它会产生下列结果： 0 5 10 15 20 a b c d e2。
```

​		此外，泛型方法是指通过泛型来约束方法中的参数类型，也可以理解为对数据类型设置了参数。如果没有泛型，每次方法中的参数类型都是固定的，不能随意更改。在使用泛型后，方法中的数据类型则有指定的泛型来约束，即可以根据提供的泛型来传递不同类型的参数。例如，下面的程序说明了这个概念：

```C#
using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
    class Program
    {
        static void Swap<T>(ref T lhs, ref T rhs)
        {
            T temp;
            temp = lhs;
            lhs = rhs;
            rhs = temp;
        }

        static void Main(string[] args)
        {
            int a, b;
            char c, d;
            a = 10;
            b = 20;
            c = 'I';
            d = 'V';

            // 在交换之前显示值
            Console.WriteLine("Int values before calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values before calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            // 调用 swap
            Swap<int>(ref a, ref b);
            Swap<char>(ref c, ref d);

            // 在交换之后显示值
            Console.WriteLine("Int values after calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values after calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            Console.ReadKey();
        }
    }
}
当上面的代码被编译和执行时，它会产生下列结果： a = 20, b = 10, c = V, d = I。
```

#### 6.密封类

​		在C#中，密封类是一种特殊的类，它使用 **sealed**关键字进行声明。密封类的主要特性是它不能被其他类继承。这意味着，如果你有一个密封类，那么没有任何类可以从这个密封类派生。

```C#
public sealed class MyClass //声明密封类
{
    public int i = 0;
    public void method()
    {
        Console.WriteLine("密封类");
    }
}

```

​		在这个例子中，`MyClass`是一个密封类，它包含一个int类型的变量和一个无返回值的方法。这些成员只能通过实例化密封类的对象来访问，而不能被继承。

​		密封类的主要用途是限制类的扩展性，防止滥用继承，使得类的层次结构体系变得复杂，使开发人员对类的理解和使用变得困难。此外，由于密封类不能被继承，因此它不能声明为抽象的，即`sealed`修饰符不能与`abstract`修饰符同时使用。

​		需要注意的是，密封类除了不能被继承外，其用法与非密封类大致相同。此外，密封类还可以提供一些运行时优化，略微提高密封类成员的调用速度。

​		总的来说，密封类是C#中一种重要的类类型，它提供了一种有效的方式来控制类的继承。
