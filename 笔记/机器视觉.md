[TOC]



# 机器视觉

## c#				

### 一、项目结构&&基础知识

#### 1.程序集信息

​		程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元。程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是.NET 应用程序的构建基块。
程序集具有以下属性：

- 程序集以 .exe 或 .dll 文件的形式实现。
- 对于面向 .NET Framework 的库，可通过将程序集放入全局程序集缓存 (GAC)，在应用程序之间共享程序集。
- 只有在需要使用时才会将程序集加载到内存中。如果未使用程序集，则不加载。
- 可以使用反射，以编程方式获取程序集的相关信息。
- 一个项目在编译后就是一个程序集。

#### 2.引用 

​		`using`关键字用于引入命名空间，也可以引入自己声明的命名空间（`using System.命名空间名称`）。

#### 3.App.config配置文件

​		`App.config`是一个应用程序配置文件，它是一个标准的XML文件这个文件可以包含一些在程序中需要使用的链接、地址等常量以及项目的配置信息，项目需要使用的特点数据信息等。开发人员可以使用配置文件来设置这些值，后期只需要更改配置文件中的配置，而不必重编译应用程序。

​		获取配置文件信息：

1.  在引用中导入Configuration
2. 引入Configuration模块
3. 使用ConfigurationManager管理程序配置的功能类 

```c#
using System.Configuration;
namespace ZhiYou_226_8_Day1_1
{  
    internal class Program
    {
        static void Main(string[] args)
        {

            //ConfigurationManager 用于管理程序配置的功能类
            string NameStr =   ConfigurationManager.AppSettings["Name"].ToString();
            Console.WriteLine(NameStr);
            string NameStr1 = ConfigurationManager.AppSettings["MyConfigString"].ToString();
            Console.WriteLine(NameStr1);
            //调用静态字段
            Console.WriteLine(AppSettingConfig.resultValue1); 
            Console.ReadKey();
        }
    }
    /// <summary>
    /// 静态类AppSettingConfig
    /// </summary>
    internal static class AppSettingConfig
    {
        //静态字段
        public static string resultValue1 = ConfigurationManager.AppSettings["Name123"].ToString();

    }
}

```

#### 4.程序入口类

​		在C#项目中，`Program.cs`文件通常是程序的入口点。这个文件中包含一个`Main`方法，它是所有C#程序的入口点。当你运行一个C#程序时，它会首先执行`Main`方法。**入口文件 --> 入口类 -->入口函数**

4.1**入口函数的作用：**

1. 启动程序：当C#项目运行时，会先执行**Main**方法，执行这个函数就是执行应用程序。
2. 组织代码：**Main**方法可以将零散的代码组织在一起，使代码更具结构性和可读性。它为整个应用程序提供了一个清晰的起点。
3. 处理命令行参数：**Main**方法的参数是一个字符串数组（通常用于接受命令行参数），这个参数可以包含任意数量的命令行输入参数。

#### 5.解决方案和项目

​		1.解决方案是一个或多个项目的集合。

​		2.解决方案并不是**答案**，他只是一个**容器**，用于包含一个或多个相关项目，以及生成信息、VS窗口设置和不与特定项目关联的任何杂项文件。

​		3.解决方案由格式唯一的文本文件（.sln）描述；不应对其进行手动编辑。

#### 6.debug和release

​		1.debug调试 用来运行程序 观察程序执行过程 排查程序错误 不作为正式发布使用 可以使用断点调试功能

​		2.release发布 把调试好的程序 通过relase编译 程序更加轻量 ,并做了优化

​		3.断点调试   当需要对程序的执行过程进行逐步观察时（或者在排错时）使用断点调试

#### 7.三种注释

​		1.单行注释 //

​		2.多行注释  /**/

​		3.XML文档注释

```C#
/// <summary>
/// 管理层的工资
/// </summary>
/// <param name="money">工资</param>
/// <param name="fh">分红</param>
/// <returns></returns>
public double Calculation(double money) 
{ 
    int fh = 10000; 
    return money + fh; 
}
```

#### 8.命名空间和类

​		命名空间主要用于将项目中的代码分组，以避免命名冲突。命名空间可以包含函数、类、变量等。

​		类是一种数据类型，是结构的扩展概念，可以包含数据成员和函数成员。类是面向对象编程的基础，他定义了一种新的数据类型，你可以创建该类型的对象。

​		命名空间主要用于组织代码和避免命名冲突，而类则用于定义对象的行为和属性。

​		同一命名空间中不能定义相同名字的类，可通过定义不同的命名空间来保存相同名字的类，一个项目中可以定义多个相同名字的命名空间，但是只能代表一个。

#### 9.命名规范

​		1.必须以字母、下划线或@开头。

​		2.不可以包含任何嵌入的空格或符号，比如? - +! # % ^ & * ( ) [ ] { } . ; : " ' / \。

​		3.不能是C#中的关键字、保留字。

​		4.区分大小写，myProject和MyProject是不同的两个命名。

​		5.命名要遵循大小驼峰，大驼峰一般用于命名空间或类的命名，小驼峰用于变量或常量。

​		6.不能用C#的类库名称相同。

#### 10.WriteLine、Write、ReadLine和Read（Console）

​		WriteLine和Write用于控制台输出

​		WriteLine可输出空字符串，Write不可以；WriteLine可换行，Write不可以。



​		ReadLine和Read用于获取控制台输入字符（暂停当前程序，按回车后继续执行并返回用户输入内容）

​		ReadLine读取多字符，Read读取的是第一个字符所对应的ASCll码

### 二、数据类型

#### 1.值类型

**值类型** 的变量直接包含其值，这一位置这些数据类型的变量直接包含值。

当你将一个值类型的变量从一个方法传递给另一个方法时，系统会在另一个方法中创建一个变量的副本。两个方法中的变量修改时不会相互影响。

值类型包括：

| 类型    | 描述                               | 范围                                                         | 默认值 |
| :------ | ---------------------------------- | ------------------------------------------------------------ | ------ |
| bool    | 布尔值                             | True、False                                                  | False  |
| byte    | 8位无符号整数                      | 0到255                                                       | 0      |
| sbyte   | 8位有符号整数                      | -128到127                                                    | 0      |
| char    | 16位Unicode字符（单字符类型）      | U+0000到U+ffff                                               | '\0'   |
| decimal | 128位精确的十进制值，28-29有效位数 | <img src="D:\A_material\MachineVision\笔记\images\decimal.png" style="zoom:100%;" /> | 0.0M   |
| double  | 64位双进度浮点型                   | <img src="D:\A_material\MachineVision\笔记\images\double.png" style="zoom:100%;" /> | 0.0D   |
| float   | 32位单精度浮点型                   | <img src="D:\A_material\MachineVision\笔记\images\float.png" style="zoom:100%;" /> | 0.0F   |
| int     | 32位有符号整数                     | -2,147,483,648 到 2,147,483,647                              | 0      |
| uint    | 32位无符号整数类型                 | 0 到 4,294,967,295                                           | 0      |
| long    | 64位有符号整数类型                 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      | 0L     |
| ulong   | 64 位无符号整数类型                | 0 到 18,446,744,073,709,551,615                              | 0      |
| short   | 16 位有符号整数类型                | -32,768 到 32,767                                            | 0      |
| ushort  | 16 位无符号整数类型                | 0 到 65,535                                                  | 0      |

#### 2.引用类型

与值类型不同，**引用类型**不直接存储其值。相反它存储的是值被存储的地址。话句话说，引用类型包含指向另一个存储数据的内存位置的指针。

当你将一个引用类型的变量从一个方法传递给另一个方法时，它不会创建一个新的副本；相反，它会传递变量的地址所以，如果我们在一个方法中改变了一个变量的值，它也会在调用方法中反映出来。一方修改，另一方也会修改。

##### 2.1 对象类型（Object）

**对象（Object）类型** 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进 行类型转换。

当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。

```c#
int val = 1;
object obj = val;  // 装箱操作
object obj = 1;  // 装箱操作
int val = (int)obj;  // 拆箱操作
```

##### 2.2 API

```c#
1. Equals(Object obj)：判断当前对象是否等于另一个对象。
    object obj1 = "Hello";
    object obj2 = "Hello";
    Console.WriteLine(obj1.Equals(obj2));  // 输出：True

2. GetHashCode()：作为默认的哈希函数，返回当前对象的哈希代码。
    object obj = "Hello";
    Console.WriteLine(obj.GetHashCode());  // 输出：某个整数，这个整数是字符串"Hello"的哈希代码

3. GetType()：获取当前实例的Type。
    object obj = "Hello";
    Console.WriteLine(obj.GetType());  // 输出：System.String

4. ToString()：返回一个表示当前对象的字符串。
    object obj = 123;
    Console.WriteLine(obj.ToString());  // 输出：123

5. ReferenceEquals(Object objA, Object objB)：确定指定的Object实例是否是同一个实例。
    object obj1 = new object();
    object obj2 = obj1;
    object obj3 = new object();
    Console.WriteLine(object.ReferenceEquals(obj1, obj2));  // 输出：True
    Console.WriteLine(object.ReferenceEquals(obj1, obj3));  // 输出：False
```



2.2、动态类型（Dynamic）

在C#中，**dynamic类型**是.NET 4.0引入的一个新特性，它允许你在编译时忽略类型检查，而将类型检查推迟到运行时。

当你声明一个变量为dynamic类型时，你可以对它进行任何操作，编译器都不会进行类型检查。这意味着你可以在运行时动态地改变变量的类型。例如：

```c#
dynamic x = 10;
x = "Hello, world!";
```

在这个例子中，x首先被赋值为一个整数，然后又被赋值为一个字符串。这在编译时是完全合法的，因为x是dynamic类型。

然而，如果你在运行时对一个dynamic类型的变量进行了不合法的操作，比如调用了不存在的方法，那么会在运行时抛出异常。

dynamic类型在处理一些动态语言的交互、反射等场景时非常有用。但是，由于它会使得类型检查推迟到运行时，因此可能会增加运行时错误的风险，所以在使用时需要谨慎。

2.2.1 API

```c#
dynamic x = "hello";
Console.WriteLine(x.Length);  // 输出：5

x = 10;
Console.WriteLine(x + 20);  // 输出：30
```



##### 2.3 字符串类型（string）

**字符串（String）类型** 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。

```c#
C# string 字符串的前面可以加 @（称作"逐字字符串"）将转义字符（\）当作普通字符对待，比如：
string str = @"C:\Windows";
          ===
string str = "C:\\Windows";

@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。
string str = @"<script type=""text/javascript"">
    <!--
    -->
</script>";

 //方式1 字面量创建字符串
 string str3 = "abc";
 string str4 = @"abc";
 //方式2  通过单字符数组创建字符串
 char[] charArray = new char[5] { 'a', 'b', 'c', 'd', 'f' };
 string str5 = new string(charArray);
```

###### 2.3.1 属性&&API

```c#
属性：
 1、Length：获取字符串的长度
	string str = "Hello, World!";
	int length = str.Length; // 获取字符串长度

 2、Chars：返回指定索引的字符（也可以直接使用str[0]返回指定索引字符）
	char firstChar = str.Chars[0]; // 获取字符串的第一个字符，结果是 'H'
	char fifthChar = str.Chars[4]; // 获取字符串的第五个字符，结果是 'o'

 3、IsNullOrEmpty：检查字符串是否为空或者null
	string str1 = null;
	string str2 = "";
	string str3 = "Hello, World!";

	bool isNullOrEmpty1 = string.IsNullOrEmpty(str1); // true，因为字符串为 null
	bool isNullOrEmpty2 = string.IsNullOrEmpty(str2); // true，因为字符串为空
	bool isNullOrEmpty3 = string.IsNullOrEmpty(str3); // false，因为字符串不为空

 4、IsNullOrWhiteSpace：检查字符串是否为空、null或者仅包含空白字符
	string str1 = null;
	string str2 = "";
	string str3 = "   "; // 包含多个空白字符
	string str4 = "Hello, World!";

	bool isNullOrWhiteSpace1 = string.IsNullOrWhiteSpace(str1); // true，因为字符串为 null
	bool isNullOrWhiteSpace2 = string.IsNullOrWhiteSpace(str2); // true，因为字符串为空
	bool isNullOrWhiteSpace3 = string.IsNullOrWhiteSpace(str3); // true，因为字符串只包含空白字符
	bool isNullOrWhiteSpace4 = string.IsNullOrWhiteSpace(str4); // false，因为字符串不为空且包含非空白字符

```

```C#
API：
 1、Concat()：将多个字符串拼接成一个新的字符串。
    string str1 = "Hello";
	string str2 = "World";
	string result = string.Concat(str1, ", ", str2);

 2、ToUpper()和ToLower()：字符串大小写转换
    string upper = str.ToUpper(); // 转为大写
	string lower = str.ToLower(); // 转为小写

 3、Trim()：去除字符串两端的空白字符
    string str = "   Hello   ";
	string trimmed = str.Trim(); // 去除两端的空白字符

 4、Substring()：从字符串中提取指定索引的字符
    string str = "Hello, World!";
    string subStr = str.Substring(7, 5); // 提取从索引7开始的5个字符，结果是 "World"

 5、StartsWith()和EndWith()：检查字符串是否以特定前缀开头或后缀结尾
    string str = "Hello, World!";
	bool startsWithHello = str.StartsWith("Hello"); // 检查是否以 "Hello" 开头
	bool endsWithWorld = str.EndsWith("World!"); // 检查是否以 "World!" 结尾

 6、Replace()：替换字符串中的字符或子字符串
    string str = "Hello, World!";
	string replaced = str.Replace("Hello", "Hi"); // 替换 "Hello" 为 "Hi"

 7、Split()：根据指定字符将字符串拆分为子字符串数组。
    string str = "apple,banana,cherry";
	string[] fruits = str.Split(','); // 拆分为数组 ["apple", "banana", "cherry"]

 8、IndexOf()和LastIndexOf()：查找字符或子字符串在字符串中的位置。
    string str = "Hello, World!";
	int indexOfComma = str.IndexOf(','); // 查找逗号的位置，结果是 5
	int lastIndexOfL = str.LastIndexOf('l'); // 查找最后一个小写字母 "l" 的位置，结果是 10
 9、判断一个字符串是否以特定的前缀开头
    string input7 = Console.ReadLine();
    Console.WriteLine(input7.StartsWith(","));
```

###### 2.3.2 转义字符

```c#
 char q = '\n';  
 string r = "今天\n不好";
 string s = @"今天\n不好";  // 添加@引号中的转义字符失效 变为单字符
 bool t = r == s; // false
 string u = "D:\\A_material\\前端\\面试";
 string string2 = @"n1212121qeqeqn1212121qeqn121212
1qeqeqn1212121qen1212121qeqeqn1212121qeqeq尼qeq尼eq尼"; // 多行字符串  引号前面添加@字符串内字符可以随意换行
 string v = "\\\\\\\\" 输出为 \\\\    其中两个\\为一对 前一个将后一个转义为普通字符
     
 补充日期类型
  DateTime dateTimeValue = DateTime.Now;
  Console.WriteLine(dateTimeValue);
```

###### 2.3.3 可变字符串和不可变字符串

不可变字符串：

- 一旦创建，他们的内容就不能被修改。
- 在C#中 **System.string** 类是不可变的，这意味着一旦你创建一个字符串对象，它的内容就不能更改。
- 当对不可变字符串进行操作时，实际上会创建一个全新的字符串对象，而原始字符串对象保持不变。
- 不可变字符串具有线程安全性，因为他们不会被更改，所以多个线程可以同时访问它们而不会导致竞态条件。
- 不可变字符串的优点是安全性和性能稳定性，但在频繁修改字符串时会产生性能开销。

```c#
	string s1 = "Hello";
	string s2 = s1 + " World"; // 创建一个新的字符串对象
```

可变字符串：

- 可变字符串允许在同一对象上进行修改，而不必创建新的字符串对象。
- 在C#中，**System.Text.StringBuilder**类提供了可变字符串的支持。
- 可变字符串通常用于需要频繁修改字符串内容的情况，以提高性能。
- 可变字符串不具备不可变字符串的线程安全性，因此在多线程环境下使用时需要谨慎处理。

```c#
	StringBuilder sb = new StringBuilder("Hello");
	sb.Append(" World"); // 修改现有可变字符串，无需创建新对象
```

#### 3.变量和常量

##### 3.1变量

​		含义：用来存储特定的数据类型。

```C#
	使用方法：变量格式 变量名 = 变量值;
 				int  num = 100;
```

​		特点：1.同一变量名不能重复声明，同意作用域变量名不可重复。

​					2.同一变量名重复赋值以最后一次赋值为准。

​					3.变量只有赋值后才能使用，否则报错。

##### 3.2常量

​		含义：用来存储特定且不会改变的数据类型。

​		const在声明常量时必须给其赋值，readOnly可以先声明后赋值。

​		常量命名规范：建议全部单词大写，可用下划线 - 隔开 例：const int CONST_INT_NUMBER = 10;

```c#
	分类：1.值类型常量：const int MY_INT = 10;
		 2.字符串常量：const string MY_STRING = "Hello, World!";
		 3.readOnly：public readonly int MyReadonlyField = 10;  用来声明只读字段，只读字段只能在声明时或者在构造函数中被赋值。
		namespace Day3_1 {
             internal class Program {
                 readonly static int ReadOnlyInt = 100;
                 readonly int ReadOnlyInt1;
             }
             internal Program(int value) {
                 ReadOnlyInt1 = value;
             }
             
             static void Main(string[] args) {
                 Program test = new Program(109);
                 Console.WriteLine(test.ReadOnlyInt1);  // 109
             }
        }
```



#### 4.数据类型转换

```C#
	 int intNumber = 1;
	 //int转long     小区间转大区间（隐式类型转换）
	 long longNumber = intNumber;

	 //long转int     大区间转小区间（显式类型转换）
	 int intNumber1 = (int)longNumber;

	 //int转float    大区间转小区间（隐式类型转换）
	 float floatNumber1 = intNumber;

	 //float转long   
	 float floatNumber2 = 1.1f;
 	 long longNumber1 = (long)floatNumber2;
```

#### 5.值类型转换

```c#
	1.Parse()适用于string转换成值类型
    2.int 代表System.int32结构体 Parse属性结构体中的方法
		string strNumber = "123";
		string strNumber1 = "123啊";
		int intStrNumber = int.Parse(strNumber);
		int.Parse(strNumber);     		  // 123
		System.Int32.Parse(strNumber);	  // 123
		Console.WriteLine(intStrNumber);  // 123
        Console.WriteLine(intStrNumber.GetType()); //获取转换后的类型
	3.解决非数字转换的异常问题 使用 TryParse()转换成返回true 失败返回false 
        int ab;
		bool isSuccess = int.TryParse(strNumber1, out ab); // ab为转换后的结果
		Console.WriteLine(ab);   若isSuccess为false则转换失败，转换后的结果为0。
    4.Convert 适合各种类型相互转换
         string converStr = "123";
         int converInt = 123;
         bool converBool = true;
         int converInt1 = Convert.ToInt32(converStr); // 字符串转int值类型
         long converLong = Convert.ToInt32(converInt1); // int转long 值类型相互转换
         string converInt2 = Convert.ToString(converBool); // 布尔转字符串
	5.toString() 任何类型转string
         int num1 = 100;
		 bool bool1 = false;
		 float float1 = 1.1f;

		 Console.WriteLine(num1.ToString());   // 100
		 Console.WriteLine(bool1.ToString());  // False
		 Console.WriteLine(float1.ToString()); // 1.1
```

#### 6.算术运算符

```c#
		// +  -  *  /  %数字类型大类型和小类型结合 结果默认为大类型结果
		string strNumber = "123";
		string strNumber1 = "123";
		int intNumber = 123;
		Console.WriteLine(intNumber + strNumber1);  // 123123

		long longNumber = 111;
		ulong uLongNumber = 111;
		Console.WriteLine(longNumber + uLongNumber); // 错误代码不可执行，两个类型相加会出现二义性错误，可以手动将其中一个类型显示的转换为另一个类型在进行运算
		
		非数字类型不可以直接使用 -
        单字符使用 - 时会隐式转换为数字类型
            
        ++ -- 变量自身自增或自减1
		num++ 后置递增 先返回原来的num，然后+1
        ++num 前置递增 直接返回+1后的num
			int number = 0;
			int result = number++ * 2; // result为0，因为先返回number的值（0），然后再将number增加1

			int number = 0;
			int result = ++number * 2; // result为2，因为先将number增加1，然后返回新的number的值（1），最后乘以2
```

​			二义性错误：在C#中，当编译器无法确定应该使用哪个重载版本的方法或运算符时，就会出现二义性错误。这通常发生在你尝试对两种不同类型的操作数执行操作，而编译器找到了多个可能的匹配的方法或运算符。**longNumber**是**long**类型，**uLongNumber**是**ulong**类型。当你尝试将它们相加时，编译器无法确定应该将它们都转换为**long**还是都转换为**ulong**。因此，编译器报告了二义性错误。

#### 7.Null    ?    ??

```C#
		1.表示不引用任何对象的空引用,没有创建内存空间,存放的是空引用指针；
        2.Null类型是System.Nullable < T > 这个struct的类型
        3.值类型不能直接赋值null 引用类型可以直接赋值null
            System.Nullable<int> a = null;
            int? a1 = null;
            
         null和字符串空值和字符串空格的区别
         1.null是没有创建内存空间,
         2.字符串空值  为"" 或者string.Empty  实际上都会分配空间；
         3.字符串空格 "    "  会分配空间 空格也是ACSII  对应的符号
            
		 双问号 ??（合并运算符）
		 作用：
		 可空类型给不可空类型 赋值时 使用
		 用于判断一个变量在为 null 的时候返回一个指定的值
```

#### 8.数组

```C#
		    //不可变数组 （一维数组）
            //含义：不可变数组是一个存储相同类型元素的固定大小的顺序集合  是一种数据类型	
            //特点：数组属于引用类型，数组只能包含类型相同的元素，数组通过下标（索引值）标记元素   从左到右 从0 依次递增1

		初始化数组中的元素的方式
		数据类型[] 数组名 = {值 1, 值 2, …}
		数据类型[] 数组名 = new 数据类型[长度]{值 1，值 2,…}
		数据类型[] 数组名 = new 数据类型[长度可忽略]{值 1，值 2,…}
		数据类型[] 数组名 = new 数据类型[长度];

		// 声明一个一维数组
		int[] array1 = new int[5];

		// 声明并初始化一个一维数组
		int[] array2 = { 1, 2, 3, 4, 5, 6 };

		// 声明一个二维数组
		int[,] multiDimensionalArray1 = new int[2, 3];

		// 声明并初始化一个二维数组
		int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };

		// 声明一个交错数组
		int[][] jaggedArray = new int[6][];

		// 设置交错数组的第一个数组的值
		jaggedArray[0] = new int[4] { 1, 2, 3, 4 };

```

##### 8.1 属性&&API	

```C#
属性：	int[] array = { 1, 2, 3, 4, 5 };
	1.IsFixedSize:获取一个值，该值指示数组是否带有固定大小。
        Console.WriteLine("IsFixedSize: " + array.IsFixedSize);

    2.IsReadOnly：获取一个值，该值指示数组是否只读。
        Console.WriteLine("IsReadOnly: " + array.IsReadOnly);

 	3.Length：获取一个32位整数，该值表示所有维度的数组中的元素总数。
        Console.WriteLine("Length: " + array.Length);

    4.LongLength：获取一个64位整数，该值表示所有维度的数组中的元素总数。
        Console.WriteLine("LongLength: " + array.LongLength);

    5.Rank：获取数组的秩（维度）。
        Console.WriteLine("Rank: " + array.Rank);

API:
	1.GetValue：获取一维数组中指定位置的值。
        int[] array = { 1, 2, 3, 4, 5 };
		int firstElement = (int)array.GetValue(0);
        
    2.SetValue：给一维数组中指定位置的元素设置值。
		array.SetValue(100, 0);
        
    3.IndexOf：搜索指定的对象，返回整个一维数组中第一次出现的索引。
        int[] array = { 1, 2, 3, 4, 5 };
		int index = Array.IndexOf(array, 3);
        
    4.Reverse：逆转整个一维数组中元素的顺序。
        int[] array = { 1, 2, 3, 4, 5 };
		Array.Reverse(array);
        
    5.GetLength：获取一个32位整数，该值表示指定维度的数组中的元素总数
        int[,] array = { { 1, 2 }, { 3, 4 }, { 5, 6 } };
		int rows = array.GetLength(0);
        
    6.GetLongLength：获取一个64位整数，该值表示指定维度的数组中的元素总数。
		long longRows = array.GetLongLength(0);
        
    7.GetLowerBound：获取数组中指定维度的下界。
        int[] array = { 1, 2, 3, 4, 5 };
		int lowerBound = array.GetLowerBound(0);
        
    8.GetUpperBound：获取数组中指定维度的上界。
		int upperBound = array.GetUpperBound(0);
        
    9.Clear：根据元素的类型，设置数组中某个范围的元素为零、为false或者为null。
        int[] array = { 1, 2, 3, 4, 5 };
		Array.Clear(array, 0, array.Length);

    10.Copy：从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。
        int[] array1 = { 1, 2, 3, 4, 5 };
		int[] array2 = new int[5];		
		int[] array3 = new int[5];
		Array.Copy(array1, array3, array1.Length); // 使用Copy方法
        
    11.CopyTo：从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。
      array1.CopyTo(array2, 0); // 使用CopyTo方法  深拷贝
        
    12.Sort：使用数组的每个元素的IComparable（比较）实现来排序整个一维数组中的元素。
        int[] array = { 5, 4, 3, 2, 1 };
		Array.Sort(array);

    13.Exists：检查数组中是否存在满足指定条件的元素。
        int[] array = { 1, 2, 3, 4, 5 };
		int value = 3;
		bool exists = Array.Exists(array, element => element == value);
		if (exists) {
            Console.WriteLine("Element found in array");
        } else {
            onsole.WriteLine("Element not found in array");
        }
 
```



#### 9.可变参数

​		**params**关键字用于指定方法可以接受可变数量的参数。这些参数必须是一维数组类型，并且必须是方法参数列表的最后一个参数。

- `params`修饰的可变参数数组必须是一维数组。
- 不允许将`params`修饰符与`ref`和`out`修饰符组合起来使用，但是可以分开使用，也就是`params`前一个参数可以定义为`ref`或者`out`。
- 传递到形参`params`中的数据可以是跟`params`类型一致的数组，也可以是任意多个与该`params`类型一致的变量。还可以不发送参数。如果未发送任何参数，则 `params` 列表的长度为零。
- `params`参数必须是参数表的最后一个参数，并且在方法声明中只允许一个 `params` 关键字。
- 若实参是数组则按引用传递，若实参是变量或表达式则按值传递。

```C#
public class MyClass 
{
    public static void UseParams(params int[] list) 
    {
        for (int i = 0; i < list.Length; i++)  
        {  
            Console.Write(list[i] + " ");  
        }  
        Console.WriteLine();  
    }

    public static void UseParams2(params object[] list) 
    {
        for (int i = 0; i < list.Length; i++)  
        {  
            Console.Write(list[i] + " ");  
        }  
        Console.WriteLine();  
    }

    static void Main() 
    {
        // 您可以发送指定类型的以逗号分隔的参数列表。
        UseParams(1, 2, 3, 4);  
        UseParams2(1, 'a', "test");

        // params 参数接受零个或多个参数。
        UseParams2();

        // 可以传递数组参数，只要数组类型与所调用方法的参数类型匹配即可。
        int[] myIntArray = {5, 6, 7, 8, 9};  
        UseParams(myIntArray);

        object[] myObjArray = {2, 'b', "test", "again"};  
        UseParams2(myObjArray);
    }
}

```



#### 10.交错数组

​		数据类型为一维数组的一维数组

```C#
using System;

class MyArray
{
    static void Main(string[] args)
    {
        /* 一个由5个整型数组组成的交错数组 */
        int[][] a = new int[][] {
            new int[] {0, 0},
            new int[] {1, 2},
            new int[] {2, 4},
            new int[] {3, 6},
            new int[] {4, 8}
        };

        int i, j;

        /* 输出数组中每个元素的值 */
        for (i = 0; i < 5; i++)
            for (j = 0; j < 2; j++)
                Console.WriteLine("a[{0}][{1}] = {2}", i, j, a[i][j]);

        Console.ReadKey();
    }
}
```

#### 11.可变数组 

##### 11.1 ArrayList

​		**ArrayList**是一个可以动态调整大小的数组。与普通数组不同，您可以使用索引在指定位置添加和移除项目，**ArrayList**会自动重新调整其大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。以下是一个**ArrayList**的使用示例：

```C#
// 引入命名空间
using System.Collections;

// 新建ArrayList
ArrayList list = new ArrayList();

// 添加内容
list.Add(1);
list.Add(2);
list.Add("国庆节快乐");

```

##### 11.2 params

​		**params**关键字允许您传递任意数量的参数给方法。这些参数被存储在一个数组中，该数组可以在方法内部进行访问。以下是一个使用**params**的示例：

```C#
public void UseParams(params int[] list)
{
    for (int i = 0; i < list.Length; i++)
    {
        Console.WriteLine(list[i]);
    }
}

// 调用方法
UseParams(1, 2, 3, 4);

```

##### 11.3 List<T>

​		[在C#中，`List`是一种常用的数据结构，它是一个可以动态调整大小的数组。以下是一些常用的`List` API](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/collections)[1](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/collections)[2](https://www.cnblogs.com/hellohxs/p/14468081.html)

##### 11.4 字典（Dictionary）

​		**Dictionary < TKey,TValue > 是一个泛型集合，它以不特定的顺序存储键值对。**

- Dictionary<TKey, TValue> 存储键值对。
- 属于System.Collection.Generic命名空间。
- 实现 IDictionary <TKey，TValue>接口。
- 键必须是唯一的，不能为null。
- 值可以为null或重复。
- 可以通过在索引器中传递相关键来访问值，例如 myDictionary[key]
- 元素存储为 KeyValuePair <TKey，TValue> 对象。

```C#
	IDictionary<int, string> numberNames = new Dictionary<int, string>();
	numberNames.Add(1,"One"); //使用Add()方法添加键/值
	numberNames.Add(2,"Two");
	numberNames.Add(3,"Three");

	//以下引发运行时异常：key already added.。
	//numberNames.Add(3, "Three"); 

	foreach(KeyValuePair<int, string> kvp in numberNames)
	    Console.WriteLine("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
		
	//使用collection-initializer语法创建字典
	var cities = new Dictionary<string, string>(){
		{"UK", "London, Manchester, Birmingham"},
		{"USA", "Chicago, New York, Washington"},
		{"India", "Mumbai, New Delhi, Pune"}
	};
		
	foreach(var kvp in cities)
   		Console.WriteLine("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
```

#### 12.结构体

1. **定义**：结构体通过**struct**关键字定义
2. **实例化**：结构体可以像类一样被实例化，但是不需要使用**new**关键字。
3. **值类型**：结构体是值类型，这意味着当它们被赋值给新的变量时，或者当它们作为方法参数传递时，会创建一个新的结构体副本。因此，对副本的修改不会影响原始结构体。
4. **方法和属性**：结构体可以包含方法、属性、索引器和事件。这些成员可以使用**this**关键字来访问结构体的当前实例。
5. **继承**：所有的结构体都隐式地继承自**System.ValueType**，这是一个从**System.Object**派生的特殊类。然而，结构体不能从其他结构体或类继承，也不能作为其他结构体或类的基础。

```C#
        public struct Point {
            public int X { get; set; }
            public int Y { get; set; }
        }

        Point p = new Point();
        p.X = 10;
        p.Y = 20;
        Console.WriteLine($"The point is at ({p.X}, {p.Y})");
```

#### 13.枚举

​		**枚举（enum）是一种特殊的值类型，它可以包含一组命名的常量。**

1. **定义**：枚举通过**enum**关键字定义。
2. **使用**：您可以像使用其他值类型一样使用枚举。例如，您可以创建一个**Days**类型的变量，并给它赋值。
3. **整数值**：默认情况下，枚举的每个元素都会被赋予一个整数值，从0开始，按声明的顺序递增。您也可以手动指定元素的值。
4. **转换**：您可以在枚举和整数之间进行转换。例如，您可以将**Days.Monday**转换为整数，或者将整数转换为**Days**。

```C#
        public enum Days {
            Sunday,
            Monday,
            Tuesday,
            Wednesday,
            Thursday,
            Friday,
            Saturday
        }
        Days today = Days.Monday;


        public enum Days {
            Sunday = 1,
            Monday = 2,
            // ...
        }
        int dayNumber = (int)Days.Monday;  // 结果是2
        Days day = (Days)2;  // 结果是Days.Monday

```

#### 14.委托

​		**委托（delegate）是一种引用类型，它可以用来封装一个方法，这个方法可以有参数，也可以有返回值**。

1. **定义**：委托通过**delegate**关键字定义。

```C#
		public delegate void MyDelegate(string message);
```

2. **实例化**：您可以像使用其他类型一样使用委托。例如，您可以创建一个**MyDelegate**类型的变量，并给它赋值一个方法。

```c#
        public void ShowMessage(string message) {
            Console.WriteLine(message);
        }

        MyDelegate del = ShowMessage;
```

3. **调用**：您可以通过委托实例来调用方法。

```C#
        del("Hello, world!");
```

4. **多播委托**：一个委托实例可以引用多个方法，这被称为多播委托。当调用一个多播委托时，它引用的所有方法都会被调用。
   - 委托的多播只能用于返回类型为void的委托，否则只能得到最后一个方法的返回值。
   - 委托的多播可以使用+或+=运算符来添加方法，使用-或-=运算符来移除方法。
   - 委托的多播可以实现事件的订阅和发布，也可以用于异步编程和回调函数。

```C#
         //定义一个返回类型为void的委托
        delegate void MyDelegate(string s);

        class Program
        {
            //定义三个与委托匹配的方法
            static void Method1(string s)
            {
                Console.WriteLine("Method1: " + s);
            }

            static void Method2(string s)
            {
                Console.WriteLine("Method2: " + s);
            }

            static void Method3(string s)
            {
                Console.WriteLine("Method3: " + s);
            }

            static void Main(string[] args)
            {
                //创建一个委托对象，并将三个方法绑定到它
                MyDelegate md = new MyDelegate(Method1);
                md += Method2;
                md += Method3;

                //调用委托对象，会依次执行三个方法
                md("Hello");

                //输出结果：
                //Method1: Hello
                //Method2: Hello
                //Method3: Hello
            }
        }
```

5. **匿名方法和lambda表达式**：您可以使用匿名方法或lambda表达式（箭头函数）来创建委托实例，而不需要定义一个完整的方法。

```C#
        MyDelegate del = delegate(string message)
        {
            Console.WriteLine(message);
        };

        // 或者

        MyDelegate del = (string message) => Console.WriteLine(message);
```

##### 14.1 Action和Func

- Action和Func委托是C#中的两种**泛型委托**，也就是说，它们可以接受不同类型的参数和返回值，而不需要事先定义具体的类型。
- Action和Func委托的区别在于，Action委托**没有返回值**，而Func委托**有返回值**。这意味着，你可以用Action委托来执行一些操作，比如打印输出，而用Func委托来计算一些值，比如求和。
- Action和Func委托的定义和使用都很简单，你只需要指定它们的参数类型和返回值类型，然后将它们绑定到一个与之匹配的方法，就可以调用它们了。你也可以用**匿名方法**或**lambda表达式**来定义委托，这样可以省去写方法的步骤。
- Action和Func委托的优点是，它们可以**减少代码的重复**，提高代码的**可读性**和**灵活性**。你可以用它们来实现一些**回调函数**，**事件处理器**，**异步操作**等功能。

```
        //使用Action委托打印两个数的和
        Action<int, int> action1 = new Action<int, int>((a, b) => Console.WriteLine(a + b));
        action1(3, 5); //输出8

        //使用Func委托返回一个数的平方
        Func<int, int> func1 = new Func<int, int>(x => x * x);
        int result1 = func1(4); //返回16

        //使用Action委托作为回调函数
        void DoSomething(Action<string> callback)
        {
            //做一些事情
            string message = "Done";
            //调用回调函数
            callback(message);
        }

        DoSomething(s => Console.WriteLine(s)); //输出Done

        //使用Func委托作为事件处理器
        public event Func<int, int, int> OnAdd;

        public int Add(int a, int b)
        {
            //触发事件
            if (OnAdd != null)
            {
                return OnAdd(a, b);
            }
            else
            {
                return a + b;
            }
        }

        //订阅事件
        OnAdd += (x, y) => x + y + 10;

        int result2 = Add(3, 5); //返回18

```



### 三、循环语句

#### 1.for循环

​		**适用场景：适用于已知循环次数的情况，通常使用计数器控制。**

```C#
		  for (int i = 0; i < n; i++){
              // 循环体
          }

	      for (;;) {  //无限循环
    
          }
```

#### 2.while

​		**适用场景：适用于循环次数不确定，只要条件满足就继续执行的情况。**

```C#
		while (condition) {
            // 循环体
        }
```

#### 3.do-while

​		**适用场景：适用于至少需要执行一次循环体的情况，然后根据条件继续执行。**

```C#
		do {
            // 循环体
        } while (condition);
```

#### 4.foreach

​		**适用场景：适用于遍历集合、数组或其他可枚举对象的情况，无需显式计数器。**

```C#
		foreach (var item in collection) {
            // 循环体
        }
```

#### 5.break&&continue

​		**break：用于在循环中提前终止循环，通常与if语句结合使用。**

​				 	 **适用于需要在满足特定条件时立即退出循环的情况。**

​		**continue：用于跳过当前迭代的循环体中的剩余代码，继续下一次迭代。**

​				    		**适用于在特定条件下跳过某些迭代的情况。**

### 四、修饰符&&函数&&类

#### 1.访问修饰符

​		**internal**：只能在当前程序集中访问。

​		**public**：可以从任何地方访问。

​		**private**：只能在当前类中访问。

​		**protected**：只能在当前类和派生类中访问。

​		**protected internal**：可以在当前程序集或派生类中访问。

​		**private protected**：(C# 7.2+): 只能在当前程序集中的派生类中访问。

#### 2.其他修饰符

​		**static**：表示静态成员，不需要实例化即可访问。

​		**readonly**：表示只读字段，只能在构造函数中或字段初始化时分配值。

​		**const**：表示常量，其值在编译时确定，不可更改。

​		**sealed**：用于类，防止其他类继承它。

​		**abstract**：用于类和方法，表示类为抽象类，方法为抽象方法，不能直接实例化。

​		**virtual**：用于方法，表示方法可以被派生类重写。

​		**override**：用于派生类中的方法，表示重写基类中的虚拟方法。

​		**new**：允许在派生类中定义具有相同名称的新成员。

​		**partial**：用于部分类，允许将一个类分成多个文件。

#### 3.访问修饰符的区别

​		**internal**：仅对同一程序集内的类型可见。

​		**public**：对所有类型都可见。

​		**private**：仅对定义该成员的类可见

​		**protected internal**：对同一程序集内和派生类可见。

#### 4.类

##### 		4.1 不同访问权限

```C#
		public static void ConsoleNumberOne() {
            Console.WriteLine(100);
        }

		internal static void ConsoleNumberTwo() {
            Console.WriteLine(1000);
        }

		private static void ConsoleNumberThree() {
            Console.WriteLine(10000);
        }

		protected static void ConsoleNumberFour() {
            Console.WriteLine(10000);
        }
```

##### 		4.2 静态和非静态

```C#
		public static void ProgramMothod() {
            Console.WriteLine("ProgramMothod");
        }

		public void ProgramMothod1() {
            Console.WriteLine("ProgramMothod1");
        }
```

##### 		4.3 有无参数

##### 		4.4 有无返回值

##### 4.5 成员变量（字段）

1. 字段是类型的成员，也称为成员变量，在类中字段也可以叫全局变量，在整个类中可以使用。
2. 字段是定义在类中方法之外的，局部变量是定义在方法内部的。
3. 字段的格式：访问修饰符 数据类型 变量名。
4. 字段都有默认值，值类型默认值为0，引用类型默认值为null，局部变量没有默认值。
5. 字段的类型为值类型和字符串类型，使用时是深拷贝（会克隆），其他的引用类型默认是浅拷贝（不克隆，赋原值）。
6. 字段的访问修饰符。
7. 在一个类中不可重复定义字段，允许定义相同名字的字段或局部变量，调用采用就近原则。
8. 命名规则： _ + 小驼峰 保持和系统框架中的字段名字一致。
9. 字段包含静态和非静态（实例调用）。
10. const定义的常量不能使用static，因为const描述的字段 本质就是包含静态的含义。
11. readonly定义的常亮可以使用static，可以在定义字段时赋值或者在其构造函数中赋值。
12. 一般使用字段时，都使用private，为了内部的字段不暴露给其他类。

​		但是使用private后 字段的灵活消失  ，使用类的成员-属性 来解决 字段灵活性的问题
​		实例字段 随着new对象的创建而创建
​		静态字段 在类加载的时候创建 且创建一次

##### 4.6 属性

​	属性和字段的关系：

1. 属性是类的成员函数
2. 属性是外界访问私有字段的入口
3. 属性的本质就是方法，一个属性可以分别有一个set 和 get方法组成
4. 使用大驼峰命名，一般和对应的私有字段名字保持一致
5. 可为字段添加判断逻辑

##### 4.7 构造函数

1. 本质就是方法。
2. 类创建对象时使用的特殊方法。
3. 类默认存在构造函数 
4. 构造函数的名字一定要和类名相同。
5. 构造函数分为实例构造函数、私有构造函数和静态构造函数。
6. 构造函数没有返回类型，可以带参数。
7. 构造函数自定义时，会覆盖系统默认的，系统默认的功能不能满足要求时自定义构造函数。
8. 实例构造一般使用public。
9. 私有构造函数使用private。不希望其他类创建自身的对象时（没有实例成员时）。
10. 系统会默认自带静态构造函数，在类创建时用来初始化所有的静态成员。
11. 静态构造函数没有访问修饰符，也没有参数。
12. 无参数的实例构造函数可以与静态构造函数共存。尽管参数列表相同，但属于一个类。

##### 4.8 静态类

1. 特点：

- 静态类使用 `static` 修饰符进行声明，例如：`static class MyStaticClass { ... }`。
- 静态类不能被实例化，即不能创建该类的对象。它们的主要目的是提供一个容器来组织和存储静态成员，如静态方法和静态字段。
- 静态类的所有成员都必须是静态的，包括方法和字段。实例成员在静态类中是不允许的。

2. 主要用途：

- 提供一个命名空间内的全局访问点：静态类中的静态成员可以在不创建类的实例的情况下访问。这可以用于提供全局配置、工具函数等。
- 组织相关的静态方法：静态类通常用于组织一组相关的静态方法，这些方法在应用程序中执行相似的操作。
- 避免不必要的实例化：某些情况下，不需要创建类的实例，只需要调用其中的方法，这时使用静态类可以避免不必要的对象实例化。

##### 4.9 继承（Inheritance）

- 继承是一种机制，它允许一个类（子类或派生类）基于另一个类（父类或基类）来创建新的类。
- 子类继承了父类的成员，包括字段、属性、方法等。
- 继承有助于实现代码重用，避免重复编写相似的代码，并构建层次结构，使代码更有层次性。		

​		继承是面向对象编程（OOP）中的一个重要概念，C#也支持继承。在C#中，继承允许你创建一个新的类（子类或派生类），该类可以继承另一个现有类（父类或基类）的成员，如字段、属性、方法和事件。子类继承了父类的特性，并且可以添加自己的成员或覆盖继承的成员。

###### 4.9.1 **基类和派生类**：

- 基类是被继承的类，也称为父类。派生类是继承基类的类，也称为子类。
- 派生类可以继承一个基类的成员，包括字段、属性、方法等。

###### 4.9.2 **语法**：

- 使用冒号 `:` 后跟基类的名称来声明派生类。例如：`class ChildClass : ParentClass`。
- 派生类可以继承所有非私有的基类成员。
- 派生类可以添加自己的成员，包括字段、属性、方法等。
- 派生类可以覆盖（重写）基类的虚拟方法或属性。

###### 4.9.3 **访问修饰符**：

- 成员的访问修饰符（public、protected、private等）控制了它们在派生类中的可见性。
- `public` 成员可以在派生类和外部访问。
- `protected` 成员只能在派生类内部访问。
- `private` 成员只能在基类内部访问。

###### 4.9.4 **重写和隐藏**：

- 派生类可以使用 `override` 关键字重写基类的虚拟方法。
- 如果不使用 `override`，则在派生类中的同名方法将会隐藏基类中的方法，这被称为方法的隐藏。

```C#
	class ParentClass {
        public void Print() {
            Console.WriteLine("This is from the ParentClass");
        }
    }

	class ChildClass : ParentClass {
        public void Display() { 
            Console.WriteLine("This is from the ChildClass");
        }

        public override void Print() {
            Console.WriteLine("This is from the ChildClass (overridden method)");
        }
    }
	在上面的示例中，ChildClass 继承了 ParentClass，并重写了 Print 方法。子类添加了自己的 Display 方法。通过创建 ChildClass 的对象，你可以访问父类的成员以及子类自己的成员。
```

##### 4.10 封装（Encapsulation）

- 封装是将数据和操作数据的方法捆绑在一起的概念。
- 在C#中，你可以使用类来实现封装。类将数据成员（字段）和方法封装在一起，并通过访问修饰符（如 `private`、`public`、`protected`）来控制对数据的访问。
- 封装可以隐藏数据的具体实现细节，同时提供公共接口供其他代码使用，这有助于保护数据的完整性和安全性。

##### 4.11 多态 （Polymorphism）

- 多态是一个对象可以表现出多种不同的形态的能力。
- 在C#中，多态通过方法的重载和重写来实现。方法的多态性允许在不同的上下文中使用相同的方法名称，但具体执行的代码根据调用的对象类型而不同。
- 多态性有助于提高代码的灵活性，允许在运行时决定使用哪个具体的实现。

##### 4.12 重载（Overloading）

- 方法重载是指在同一个类中定义多个具有相同名称但不同参数列表的方法。
- C#编译器会根据调用时提供的参数类型或数量来选择正确的重载方法。
- 方法重载有助于提供不同参数组合的方法，以便更方便地使用相同方法名称。

##### 4.13 重写（Overriding）

- 方法重写是指子类可以提供一个新的实现来覆盖基类中的方法。
- 重写通常与多态性一起使用，它允许子类根据自己的需求重新实现继承的方法。
- 重写的方法必须具有与基类方法相同的名称、参数和返回类型，并使用 `override` 关键字标记。
- 使用关键字 virtual，将父类的方法标记为虚方法（父类允许子类覆盖方法的标签）用 override  关键字，虚方法可以被子类重写。

##### 4.13  base

- base关键字用于从派生类中访问基类的成员；
- 派生类对象调用基类构造函数；
- 调用基类上已被重写的方法；
- 不能从静态方法中使用base关键字，base关键字只能在实例构造函数、实例方法或实例访问器中使用。

```C#
	访问基类成员：
		在派生类中，你可以使用 base 关键字来访问基类的成员，包括字段、属性和方法。
		这是有用的，当派生类和基类有同名成员时，使用 base 可以明确指定要调用基类的成员
	class BaseClass {
        public void Display() {
            Console.WriteLine("This is from the BaseClass");
        }
    }

	class DerivedClass : BaseClass {
        public void Display() {
            Console.WriteLine("This is from the DerivedClass");
        }

    	public void ShowBaseDisplay() {
            base.Display(); // 调用基类的 Display 方法
        }
    }

	调用基类构造函数： 
		在派生类的构造函数中，你可以使用 base 关键字来调用基类的构造函数。
		这是有用的，当你需要执行基类构造函数的初始化操作，然后再执行派生类构造函数的操作。
    using System;
	class Animal {
        public string Name { get; set; }
        public Animal(string name) {
            Name = name;
            Console.WriteLine($"Animal {Name} is born.");
        }
        
        public void Eat() { 
            Console.WriteLine($"{Name} is eating.");
        }
    }

	class Dog : Animal {
        public string Breed { get; set; }
        public Dog(string name, string breed) : base(name) { 
            Breed = breed;
            Console.WriteLine($"Dog {Name} of breed {Breed} is born.");
        }
        
        public void Bark() {
            Console.WriteLine($"{Name} is barking.");
        }
    }

	class Program {
        static void Main(string[] args) {
            Dog myDog = new Dog("Buddy", "Golden Retriever");
            myDog.Eat();
            myDog.Bark();
        }
    }
	在上述示例中，Animal 类和 Dog 类之间建立了继承关系。Dog 类的构造函数使用 base(name) 来调用基类 Animal 的构造函数，以确保 Name 属性在创建 Dog 对象时得到初始化。这样，可以在构造函数中完成一些初始化工作，并确保正确设置属性值。
	在 Main 方法中，我们创建了一个 Dog 对象，并演示了如何访问基类和派生类的成员。这个示例显示了如何使用 base 来调用基类构造函数，以便在继承关系中正确初始化对象。
```

##### 4.14 接口

1. 接口定义了所有类继承接口时应遵循的语法合同。
2. 接口定义了语法合同的"是什么"部分，派生类定义了语法合同的"怎么做"部分。
3. 接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。
4. 成员的定义是派生类的责任。
5. 接口提供了派生类应遵循的标准结构。
6. 接口使得实现接口的类或结构在形式上保持一致。
7. 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。
8. 接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。
9. 抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。
10. 接口使用`interface`关键字声明，它与类的声明类似。接口声明默认是`public`的。

```C#
interface IMyInterface {
    void MethodToImplement();
}
```

##### 4.15  抽象类

​		在C#中，抽象类是一种特殊的类，它使用abstract关键字进行声明。抽象类的主要特性是它不能被实例化，只能被其他类继承。这意味着，如果你有一个抽象类，那么没有任何类可以直接创建这个抽象类的实例。抽象类可以包含抽象方法和非抽象方法。抽象方法是一种特殊的方法，它在抽象类中被声明，但没有具体的实现。抽象方法必须在任何非抽象类（即，继承抽象类的类）中被重写。

```c#
public abstract class AbstractClass
{
    public abstract void AbstractMethod();

    public void NonAbstractMethod()
    {
        // Implementation here...
    }
}

```

​		在这个例子中，**AbstractClass**是一个抽象类，它包含一个抽象方法**AbstractMethod**()和一个非抽象方法**NonAbstractMethod**()。这些方法只能通过实例化继承抽象类的类来访问，而不能通过实例化抽象类本身来访问。

​		抽象类的主要用途是作为其他类的基类。它为派生类提供了一个通用的、标准的基本模板。派生类可以继承抽象类的成员，也可以重写抽象类中的抽象方法。

​		需要注意的是，抽象类除了不能被实例化外，其用法与非抽象类大致相同。此外，抽象类还可以提供一些运行时优化，略微提高抽象类成员的调用速度。

##### 4.16 接口和抽象类的异同

**相同点**：

- [抽象类和接口都是抽象的，不能实例化，需要子类实现其抽象成员](https://zhuanlan.zhihu.com/p/511932063)[4](https://zhuanlan.zhihu.com/p/511932063)。

**不同点**：

1. [**继承**：接口可以被多重实现，抽象类只能被单一继承](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[1](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[3](https://www.cnblogs.com/HomeSapiens/p/17298584.html)[5](https://zhuanlan.zhihu.com/p/463345426)。
2. [**成员实现**：抽象类可以包含已实现的成员，而接口不能包含任何成员的实现](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[1](https://www.cnblogs.com/sunzhenyong/p/3814910.html)[2](https://zhuanlan.zhihu.com/p/357098839)[4](https://zhuanlan.zhihu.com/p/511932063)。
3. [**成员类型**：抽象类可以定义字段、方法、属性、事件、索引器的实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
4. [**访问修饰符**：接口中的成员访问类型默认为公共的，不能有其他的访问修饰符修饰](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
5. [**关键字**：定义的关键字不一样，抽象类需要使用`abstract`，而接口则使用`interface`](https://bing.com/search?q=)[6](https://bing.com/search?q=)。
6. [**回调支持**：接口可以用于支持回调，抽象类不能实现回调](https://www.cnblogs.com/HomeSapiens/p/17298584.html)[3](https://www.cnblogs.com/HomeSapiens/p/17298584.html)。

**使用场景**：

- [如果对象存在多个功能相近且关系紧密的版本，则使用抽象类](https://zhuanlan.zhihu.com/p/357098839)[2](https://zhuanlan.zhihu.com/p/357098839)。
- [如果对象关系不密切，但是若干功能拥有共同的声明，则使用接口](https://zhuanlan.zhihu.com/p/357098839)[2](https://zhuanlan.zhihu.com/p/357098839)。

#### 5.泛型

​		在C#中，泛型（Generic）是一种规范，它允许我们使用占位符来定义类和方法，编译器会在编译时将这些占位符替换为指定的类型。这意味着，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

[使用泛型是一种增强程序功能的技术，具体表现在以下几个方面](https://www.runoob.com/csharp/csharp-generic.html)[2](https://www.runoob.com/csharp/csharp-generic.html)：

- 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。
- 您可以创建泛型集合类。.NET 框架类库在 System.Collections.Generic 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 System.Collections 中的集合类。
- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
- 您可以对泛型类进行约束以访问特定数据类型的方法。
- 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。

```C#
using System;
using System.Collections.Generic;

namespace GenericApplication
{
    public class MyGenericArray<T>
    {
        private T[] array;
        public MyGenericArray(int size)
        {
            array = new T[size + 1];
        }
        public T getItem(int index)
        {
            return array[index];
        }
        public void setItem(int index, T value)
        {
            array[index] = value;
        }
    }

    class Tester
    {
        static void Main(string[] args)
        {
            // 声明一个整型数组
            MyGenericArray<int> intArray = new MyGenericArray<int>(5);
            // 设置值
            for (int c = 0; c < 5; c++)
            {
                intArray.setItem(c, c * 5);
            }
            // 获取值
            for (int c = 0; c < 5; c++)
            {
                Console.Write(intArray.getItem(c) + " ");
            }
            Console.WriteLine();
            // 声明一个字符数组
            MyGenericArray<char> charArray = new MyGenericArray<char>(5);
            // 设置值
            for (int c = 0; c < 5; c++)
            {
                charArray.setItem(c, (char)(c + 97));
            }
            // 获取值
            for (int c = 0; c < 5; c++)
            {
                Console.Write(charArray.getItem(c) + " ");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
当上面的代码被编译和执行时，它会产生下列结果： 0 5 10 15 20 a b c d e2。
```

​		此外，泛型方法是指通过泛型来约束方法中的参数类型，也可以理解为对数据类型设置了参数。如果没有泛型，每次方法中的参数类型都是固定的，不能随意更改。在使用泛型后，方法中的数据类型则有指定的泛型来约束，即可以根据提供的泛型来传递不同类型的参数。例如，下面的程序说明了这个概念：

```C#
using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
    class Program
    {
        static void Swap<T>(ref T lhs, ref T rhs)
        {
            T temp;
            temp = lhs;
            lhs = rhs;
            rhs = temp;
        }

        static void Main(string[] args)
        {
            int a, b;
            char c, d;
            a = 10;
            b = 20;
            c = 'I';
            d = 'V';

            // 在交换之前显示值
            Console.WriteLine("Int values before calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values before calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            // 调用 swap
            Swap<int>(ref a, ref b);
            Swap<char>(ref c, ref d);

            // 在交换之后显示值
            Console.WriteLine("Int values after calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values after calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            Console.ReadKey();
        }
    }
}
当上面的代码被编译和执行时，它会产生下列结果： a = 20, b = 10, c = V, d = I。
```

#### 6.密封类

​		在C#中，密封类是一种特殊的类，它使用 **sealed**关键字进行声明。密封类的主要特性是它不能被其他类继承。这意味着，如果你有一个密封类，那么没有任何类可以从这个密封类派生。

```C#
public sealed class MyClass //声明密封类
{
    public int i = 0;
    public void method()
    {
        Console.WriteLine("密封类");
    }
}

```

​		在这个例子中，`MyClass`是一个密封类，它包含一个int类型的变量和一个无返回值的方法。这些成员只能通过实例化密封类的对象来访问，而不能被继承。

​		密封类的主要用途是限制类的扩展性，防止滥用继承，使得类的层次结构体系变得复杂，使开发人员对类的理解和使用变得困难。此外，由于密封类不能被继承，因此它不能声明为抽象的，即`sealed`修饰符不能与`abstract`修饰符同时使用。

​		需要注意的是，密封类除了不能被继承外，其用法与非密封类大致相同。此外，密封类还可以提供一些运行时优化，略微提高密封类成员的调用速度。

​		总的来说，密封类是C#中一种重要的类类型，它提供了一种有效的方式来控制类的继承。

#### 

### 五、常见异常

- System.IO.IOException：处理 I/O 错误，比如文件不存在或无法访问。
- System.IndexOutOfRangeException：处理当方法指向超出范围的数组索引时生成的错误。
- System.NullReferenceException：处理当依从一个空对象时生成的错误。
- System.DivideByZeroException：处理当除以零时生成的错误。
- System.InvalidCastException：处理在类型转换期间生成的错误。
- System.OutOfMemoryException：处理空闲内存不足生成的错误。
- [System.StackOverflowException：处理栈溢出生成的错误。

```C#
        try {
            // 尝试除以零
            int a = 10;
            int b = 0;
            int c = a / b;
            Console.WriteLine("The result is {0}", c);
        } catch (DivideByZeroException ex) {
            // 捕获除以零的异常
            Console.WriteLine("An exception occurred: {0}------", ex.Message);
            Console.WriteLine(ex.ToString() + "-----");  // 和系统报错显示一样
            // 抛出异常
            throw;
        } finally {
            // 无论是否发生异常都要执行的代码
            Console.WriteLine("The program ends.");
        }
		如果您运行这个代码示例，您会发现控制台上显示了异常的完整信息，其中 throw; 和 throw ex; 的效果是不一样的，前者保留了原始异常的堆栈跟踪信息，后者重置了堆栈跟踪信息。
```

- throw; 是不带参数的，它会将原始异常原封不动地重新抛出，保留了异常发生的位置和原因，方便调试和定位问题。
- throw ex; 是带参数的，它会创建一个新的异常对象，并且重置了堆栈跟踪信息，导致原始异常的位置和原因被丢失，只能看到 catch 块中的位置，不利于调试和定位问题。

### 六、folder&&file操作

```C#
		// 使用 Directory 类的 GetCurrentDirectory 方法获取当前工作目录
		string currentPath = Directory.GetCurrentDirectory();

		// 使用 Directory 类的 GetParent 方法获取当前工作目录的父目录
		DirectoryInfo parentPath = Directory.GetParent(currentPath);

		// 使用 Directory 类的 GetParent 方法获取父目录的父目录，即解决方案路径
		DirectoryInfo solutionPath = Directory.GetParent(parentPath.FullName);
```

#### 1、using (FileStream file = File.Create(filePath))作用

1. `File.Create(filePath)` 创建一个 `FileStream` 对象，并打开或创建指定路径的文件。
2. `using` 语句确保在代码块结束时自动调用 `file.Dispose()` 方法，这样就会释放文件资源，关闭文件句柄。这是通过实现 `IDisposable` 接口来实现的，`FileStream` 是一个实现了 `IDisposable` 的类。
3. 在 `using` 代码块中，你可以执行需要使用 `file` 对象进行的任何文件操作，例如读取或写入文件。

​		总的来说，这行代码用于创建一个文件并获得对该文件的访问权限。`using` 语句确保在你完成对文件的操作后，资源被及时释放，而不会在程序运行时占用文件句柄。这对于确保代码的健壮性和资源管理是非常重要的。

#### 2.代码的健壮性

​		**代码的健壮性**通常指的是代码能够处理各种不同情况和输入，而不会崩溃或产生不可预测的行为。对于文件操作等资源管理方面，代码的健壮性包括正确处理资源的获取和释放，以及对可能出现的异常进行适当的处理。

在文件操作中，`using` 语句在一定程度上提高了代码的健壮性，具体有以下几方面的好处：

1. **资源释放：** `using` 语句确保在代码块结束时自动调用对象的 `Dispose` 方法。对于文件操作，这意味着文件句柄会被及时释放，而不会导致文件被锁定或其他资源泄漏。
2. **异常处理：** 如果在文件操作中发生异常，`using` 语句会确保资源被释放。这有助于防止资源泄漏，并使代码更容易调试和理解。在你的代码中，你已经使用 `try-catch` 块来捕获异常，并输出了错误信息，这也是一种处理异常的方式。
3. **简化代码：** `using` 语句可以使代码更简洁，减少了手动资源管理的复杂性。通过使用 `using`，你可以避免手动调用 `Dispose` 方法，提高了代码的可读性和可维护性。

​		总的来说，通过良好的资源管理和异常处理，代码的健壮性得以提高，更容易维护和改进。这对于确保软件在各种情况下都能稳健运行是至关重要的。

### 七、线程&&进程

#### 1.线程

​		线程是程序中的一个**执行流**，每个线程都有自己的专有寄存器和堆栈，但代码区是共享的，即**不同的线程可以执行相同的函数**。线程可以**提高程序的效率和响应性，实现多任务的并行处理**。

​		在C#中，使用**System.Threading.Thread**类来创建和管理线程。Thread类提供了一些属性和方法来控制线程的行为，例如：

- **Name**：获取或设置线程的名称，用于标识和调试。
- **Priority**：获取或设置线程的优先级，用于影响线程的调度。
- **IsAlive**：获取线程是否已经启动并且没有终止。
- **IsBackground**：获取或设置线程是否为后台线程，后台线程不会阻止进程终止。
- **Start**：开始线程的执行。
- **Join**：阻塞调用线程，直到当前线程终止。
- **Sleep**：暂停当前线程一段时间。
- **Abort**：终止当前线程，但不推荐使用，因为可能导致资源泄漏和不一致的状态。
- **Interrupt**：中断处于 WaitSleepJoin 状态的线程，使其抛出 ThreadInterruptedException 异常。
- **Suspend**：暂停当前线程，但已过时，不推荐使用，因为可能导致死锁和不一致的状态。
- **Resume**：恢复暂停的线程，但已过时，不推荐使用，因为可能导致死锁和不一致的状态。

​		要创建一个线程，需要传递一个 ThreadStart 或 ParameterizedThreadStart 委托给 Thread 类的构造函数，指定线程要执行的方法。

```C# 
        // 无参数的线程方法
        static void PrintNums() {
            Console.WriteLine("starting ...........");
            for (int i = 0; i < 10; i++) {
                Console.WriteLine(i);
            }
            Console.WriteLine("end......");
        }

        // 有参数的线程方法
        static void PrintNums(object max) {
            int num = Convert.ToInt32(max);
            Console.WriteLine("starting ...........");
            for (int i = 0; i < num; i++) {
                Console.WriteLine(i);
            }
            Console.WriteLine("end......");
        }

        // 创建一个线程，使用无参数的线程方法
        Thread t1 = new Thread(PrintNums);
        t1.Start();

        // 创建一个线程，使用有参数的线程方法
        Thread t2 = new Thread(PrintNums);
        t2.Start(5);

```

​		

​		要等待一个线程完成，可以使用 Join 方法，它会阻塞调用线程，直到目标线程终止。

```C#
        // 等待线程 t1 完成
        t1.Join();
        Console.WriteLine("Thread t1 finished");

        // 等待线程 t2 完成，最多等待 3 秒
        bool result = t2.Join(TimeSpan.FromSeconds(3));
        if (result) {
            Console.WriteLine("Thread t2 finished");
        }
        else {
            Console.WriteLine("Thread t2 timeout");
        }

```



​		要暂停一个线程一段时间，可以使用 Sleep 方法，它会让当前线程进入休眠状态，不占用 CPU 资源。

```C#
        // 暂停线程 1 秒
        Thread.Sleep(1000);

        // 暂停线程 1.5 秒
        Thread.Sleep(TimeSpan.FromMilliseconds(1500));
```



​		要终止一个线程，可以使用 Abort 方法，它会向目标线程注入一个 ThreadAbortException 异常，使其退出。但这种方式不推荐使用，因为可能导致资源泄漏和不一致的状态。目标线程也可以通过捕获异常并调用 Thread.ResetAbort 方法来取消终止。

```c#
            // 终止线程 t1
            t1.Abort();

            // 在线程方法中捕获异常并取消终止
            static void PrintNums()
            {
                try
                {
                    Console.WriteLine("starting ...........");
                    for (int i = 0; i < 10; i++)
                    {
                        Console.WriteLine(i);
                    }
                    Console.WriteLine("end......");
                }
                catch (ThreadAbortException)
                {
                    Console.WriteLine("Thread aborted");
                    Thread.ResetAbort();
                }
            }

```

​		

​		要中断一个处于 WaitSleepJoin 状态的线程，可以使用 Interrupt 方法，它会向目标线程注入一个 ThreadInterruptedException 异常，使其恢复运行。

```C#
        // 中断线程 t1
        t1.Interrupt();

        // 在线程方法中捕获异常并处理
        static void PrintNums()
        {
            try
            {
                Console.WriteLine("starting ...........");
                for (int i = 0; i < 10; i++)
                {
                    Console.WriteLine(i);
                    Thread.Sleep(1000); // 每次暂停 1 秒
                }
                Console.WriteLine("end......");
            }
            catch (ThreadInterruptedException)
            {
                Console.WriteLine("Thread interrupted");
            }
        }

```



- 线程的状态：线程在其生命周期中会经历不同的状态，例如 Unstarted，Running，WaitSleepJoin，Stopped 等。可以通过 ThreadState 属性来获取线程的当前状态。
- 线程的同步：当多个线程访问共享的资源时，可能会发生冲突和不一致的情况，需要使用一些同步机制来保证线程安全，例如 lock，Monitor，Mutex，Semaphore，AutoResetEvent，ManualResetEvent 等。
- 线程的本地存储：每个线程都有自己的本地存储空间，可以使用 ThreadStatic 特性或 ThreadLocal 类来声明和使用线程本地变量，这样每个线程都有自己的变量副本，不会受到其他线程的影响。
- 线程池：线程池是一种管理线程的方式，它可以复用已经创建的线程，避免频繁地创建和销毁线程，提高性能和资源利用率。可以使用 ThreadPool 类或 Task 类来使用线程池。
- 异步编程：异步编程是一种编写非阻塞代码的方式，它可以让主线程继续执行其他任务，而不必等待耗时的操作完成。可以使用 async 和 await 关键字，或者使用 Task 类和 TaskCompletionSource 类来实现异步编程。

#### 2.进程

- 动态性：进程是动态地产生、变化和消亡的，它有着创建、活动、暂停、终止等过程，具有一定的生命周期。
- 并发性：多个进程可以同时存在于内存中，并在一段时间内同时运行，实现多任务的并行处理。
- 独立性：进程是一个能独立运行、独立获得资源和独立接受调度的基本单元。
- 异步性：由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。
- 结构性：每个进程都有一个进程控制块（PCB）来描述和控制其状态和行为，PCB包含了进程的标识、状态、优先级、资源分配、处理机相关信息等。

#### 3.线程和进程的区别

- 进程是程序运行时的一个实例，它拥有独立的内存空间和系统资源，是操作系统分配和调度的基本单位。
- 线程是进程内部的一个执行单元，它共享进程的内存空间和部分系统资源，是CPU执行和分派的基本单位。
- 一个进程可以包含多个线程，这些线程可以并发或并行地执行不同的任务，提高程序的效率和响应性。
- 线程之间可以方便地共享数据和信息，但也需要进行同步和协调，避免出现竞争和死锁的问题。
- 进程之间的切换和通信比线程之间的切换和通信要消耗更多的时间和资源，因为进程之间需要保存和加载更多的上下文信息。
- 进程之间的数据和资源是相互隔离的，需要使用特定的方法（如管道，消息队列，信号量，共享内存等）来进行通信和交换。

#### 4.同步和异步

- 同步和异步是两种不同的编程模式，用于控制代码的执行方式。
- 同步模式是指代码按照从上到下的顺序依次执行，在执行一个任务时会一直阻塞在那里等待其完成。例如，如果一个任务需要从网络上下载一个文件，那么同步模式下的代码会在文件下载完成之前无法执行其他的操作，只能等待下载的结果。
- 异步模式则是指在调用一个任务后立即返回，不会等待这个任务完成，而是通过回调机制在任务完成时通知调用者，可以同时执行多个任务，提高程序的效率。例如，如果一个任务需要从网络上下载一个文件，那么异步模式下的代码会在发出下载请求后继续执行其他的操作，当文件下载完成时，会触发一个回调函数来处理下载的结果。
- C#中，异步编程的核心是Task和Task<T>对象，它们表示一个异步操作的状态和结果，可以通过await关键字来等待一个Task的完成，也可以通过ContinueWith方法来指定一个Task的后续操作。另外，C#还提供了async关键字来标记一个方法为异步方法，这样可以在方法内部使用await关键字来等待异步操作，而不会阻塞当前的线程。

##### 4.1 Task

- Task是C#中用于表示异步操作的类，它可以让您创建和执行任务，控制任务的状态和结果，等待任务的完成，以及在任务之间建立依赖和延续。
- Task可以通过多种方式创建和执行，例如使用静态方法Run，TaskFactory工厂，Task类构造函数，或者async/await关键字 。
- Task可以提高程序的性能和响应性，因为它可以在一个或多个线程池线程上异步执行，而不会阻塞主线程。
- Task还可以通过Task类来表示一个返回值的操作，可以通过Result属性或await关键字来获取任务的结果。

**无返回值的方式：**

```C#
	static void Main(string[] args)
        {
            //方式1:调用Start方法
            var t1 = new Task(() => TaskMethod("Task 1"));
            var t2 = new Task(() => TaskMethod("Task 2"));
            t1.Start();
            t2.Start();
            Task.WaitAll(t1, t2);//等待所有任务结束，主线程才会退出
            //任务的状态：Start之前为Created，之后为WaitingToRun

            //方式2:静态方法Run
            Task.Run(() => TaskMethod("Task 3"));

            //方式3:TaskFactory工厂
            // 方法1. TaskFactory工厂
            TaskFactory taskFactory = new TaskFactory();
            taskFactory.StartNew(() => TaskMethod("Task 4"));
            // 方法2. Task.Factory属性
            Task.Factory.StartNew(() => TaskMethod("Task 5"));
            //或者
            var t3 = Task.Factory.StartNew(() => TaskMethod("Task 6"));
            Task.WaitAll(t3);

            //方式4:RunSynchronously同步启动
            //Task实例化后调用同步方法RunSynchronously，进行线程启动。
            //(PS: 类似委托开启线程，BeginInvoke是异步，而Invoke是同步)
            var t4 = new Task(() => TaskMethod("Task 7"));
            t4.RunSynchronously();

            //async/await的实现方式
            AsyncFunction();

            Console.ReadKey();
        }

        static void TaskMethod(string name)
        {
            Console.WriteLine("Task {0} is running on a thread id {1}. Is thread pool thread: {2}",
                name, Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread);
        }

        async static void AsyncFunction()
        {
            await Task.Delay(1);
            Console.WriteLine("使用`System.Threading.Tasks.Task`执行异步操作.");
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine(string.Format("AsyncFunction:i= {0}", i));
            }
        }
```

**带返回值的方式：**

```C#
	static void Main(string[] args)
        {
            //方式1:使用Result属性获取返回值
            var t1 = new Task<int>(() => TestMethod1());
            t1.Start();
            Console.WriteLine("t1的返回值是{0}", t1.Result);

            //方式2:使用async/await获取返回值
            var t2 = TaskMethod2();
            Console.WriteLine("t2的返回值是{0}", await t2);//使用await关键字获取返回值，不会阻塞当前线程，而是在任务完成后继续执行

            Console.ReadKey();
        }

        static int TestMethod1()
        {
            Console.WriteLine("测试方法");
            Thread.Sleep(2000);
            return 12;
        }

        static async Task<int> TaskMethod2()
        {
            int sum = 0;
            Console.WriteLine("执行异步操作");
            for (int i = 0; i < 100; i++)
            {
                sum += i;
            }
            await Task.Delay(1000);
            return sum;
        }
```

常用方法：

Start(): 启动一个未启动的Task，将其安排到当前的TaskScheduler中执行。

```C#
        //创建一个未启动的Task，打印Hello
        var t = new Task(() => Console.WriteLine("Hello"));
        //启动Task，将其安排到当前的TaskScheduler中执行
        t.Start();
```

Wait(): 阻塞当前的线程，直到Task完成或超时。  

```C#
        //创建并执行一个Task，延迟1秒后打印Hello
        var t = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Hello"); });
        //等待Task完成，或者超过2秒
        t.Wait(2000);
```

WaitAll(): 阻塞当前的线程，直到所有提供的Task对象都完成或超时。

```C#
        //创建并执行两个Task，分别延迟1秒和2秒后打印Hello
        var t1 = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Hello"); });
        var t2 = Task.Run(() => { Thread.Sleep(2000); Console.WriteLine("Hello"); });
        //等待两个Task都完成，或者超过3秒
        Task.WaitAll(new[] { t1, t2 }, 3000);
```

WaitAny(): 阻塞当前的线程，直到任何一个提供的Task对象完成或超时。

```C#
        //创建并执行两个Task，分别延迟1秒和2秒后打印Hello
        var t1 = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Hello"); });
        var t2 = Task.Run(() => { Thread.Sleep(2000); Console.WriteLine("Hello"); });
        //等待任何一个Task完成，或者超过3秒，返回完成的Task的索引
        int index = Task.WaitAny(new[] { t1, t2 }, 3000);
```

ContinueWith(): 创建一个在目标Task完成时异步执行的延续任务。

```C#
        //创建并执行一个Task，返回10
        var t = Task.Run(() => 10);
        //创建一个在t完成后执行的延续任务，打印t的结果
        var t2 = t.ContinueWith(task => Console.WriteLine(task.Result));
```

Run(): 在线程池中创建并执行一个Task。

```C#
        //创建并执行一个Task，打印Hello
        Task.Run(() => Console.WriteLine("Hello"));
```

RunSynchronously(): 在当前的线程上同步执行一个Task。

```C#
        //创建一个未启动的Task，打印Hello
        var t = new Task(() => Console.WriteLine("Hello"));
        //在当前线程上同步执行Task
        t.RunSynchronously();
```

FromResult(): 创建一个已完成的Task，并返回指定的结果。

```C#
        //创建一个已完成的Task，返回10
        var t = Task.FromResult(10);
        //打印Task的结果
        Console.WriteLine(t.Result);
```

Delay(): 创建一个在指定时间间隔后完成的Task。

```C#
        //创建一个延迟1秒后完成的Task
        var t = Task.Delay(1000);
        //等待Task完成
        t.Wait();
```

WhenAll(): 创建一个在所有提供的Task对象都完成时完成的Task。

```C#
        //创建并执行两个Task，分别返回10和20
        var t1 = Task.Run(() => 10);
        var t2 = Task.Run(() => 20);
        //创建一个在两个Task都完成后完成的Task，返回两个Task的结果数组
        var t3 = Task.WhenAll(t1, t2);
        //打印t3的结果
        Console.WriteLine(t3.Result[0] + t3.Result[1]);
```

WhenAny(): 创建一个在任何一个提供的Task对象完成时完成的Task。

```C#
        //创建并执行两个Task，分别返回10和20
        var t1 = Task.Run(() => 10);
        var t2 = Task.Run(() => 20);
        //创建一个在两个Task都完成后完成的Task，返回两个Task的结果数组
        var t3 = Task.WhenAll(t1, t2);
        //打印t3的结果
        Console.WriteLine(t3.Result[0] + t3.Result[1]);
```

##### 4.2 CancellationTokenSource

- CancellationTokenSource是一个类，它用于创建和发送一个取消令牌，以实现协作式的取消模型。
- 协作式的取消模型是指一个对象可以发起一个取消请求，通知一个或多个正在执行的操作停止工作，而每个操作都可以自主决定如何响应取消请求。
- CancellationTokenSource类提供了以下的功能
  - 通过其Token属性，可以获取一个与之关联的CancellationToken对象，该对象可以传递给需要监听取消请求的操作。
  - 通过调用其Cancel或CancelAfter方法，可以向所有拷贝的取消令牌发送一个取消请求，使其IsCancellationRequested属性变为true。
  - 通过调用其Dispose方法，可以释放其占用的非托管资源。

```C#
        //定义一个取消令牌源
        CancellationTokenSource source = new CancellationTokenSource();
        //获取其取消令牌
        CancellationToken token = source.Token;
        //创建并执行一个任务，监听取消请求
        Task task = Task.Run(() =>
        {
            //模拟一个长时间的工作
            for (int i = 0; i < 100; i++)
            {
                //检查是否有取消请求
                if (token.IsCancellationRequested)
                {
                    //响应取消请求，退出循环
                    Console.WriteLine("Task canceled");
                    break;
                }
                //继续工作
                Console.WriteLine("Task working");
                Thread.Sleep(100);
            }
        }, token);
        //在一定时间后，发起取消请求
        Thread.Sleep(500);
        source.Cancel();
        //等待任务结束
        task.Wait();
        //释放取消令牌源
        source.Dispose();
```









## VisionPro

### 一、工具

#### 1.CogPMAlignTool（模板匹配）

#### 2.CogFixtureTool（定位工具）

#### 3.CogPMAlignMultiTool（多模板）匹配

​		**Runtime Mode**（查找模式）：

1. **Sequential:**

   ​		顺序模式，可能是按照设置的顺序依次执行不同的查找类型。可能会在找到一个匹配后停止进一步的查找。

2. **SequentialMostRecentTlySussessful:**

   ​		顺序最近成功模式，可能是按照设置的顺序依次执行不同的查找类型，但会考虑到最近成功的查找结果，以提高效率。

3. **SequentialMostSuccessful:**

   ​		顺序最成功模式，可能是按照设置的顺序依次执行不同的查找类型，但会考虑到历史上最成功的查找结果，以提高效率。

4. **Exhaustive:**

   ​		全面模式，尝试查找图像中的所有可能匹配，并返回所有匹配结果。这样，你可以获得多个匹配结果，而不仅仅是第一个或最佳的匹配。

#### 4.CogImageConvertTool1（图片转换——彩色转黑白）

#### 5.CogPolarUnwrapTool（极性展开——将圆形平铺成直线）

#### 6.CogSobelEdgeTool（边缘提取工具）

#### 7.CogCopyRegionTool（复制图像中部分区域）

- 从输入图像中复制一部分到新的输出图像；
- 从输入图像中复制一部分到已存在的目标图像；
- 用固定的像素值对图像中的部分区域进行填充；

**CogCopyRegionTool工具的应用场景包括：**

- 对图像中的某些区域进行掩膜处理，将其屏蔽为其他像素的区域；
- 对图像中的某些区域进行裁剪，只保留感兴趣的部分；
- 对图像中的某些区域进行填充，改变其颜色或灰度值；

#### 8.CogBlobTool（斑点分析）

​		顶点信息：**添加终端**---->**Results**（所有）---->**GetBlobs()**---->**Item**---->**GetBoundary()**（多边形对象）---->**GetParentRromChildTransform()**（总 结点数）

### 二、脚本

#### 1.CogGraphicLabel（label标签）

#####  	API

```C#
		// 定义标签
		private CogGraphicLabel myLabel = new CogGraphicLabel();

		// 设置标签位置以及内容
		myLabel.SetXYText(200, 200,ying "文本内容");				 	

		// 将标签添加至指定图片
		mToolBlock.AddGraphicToRunRecord(myLabel,lastRecord,"CogFixtureTool1.OutputImage",""); 

		// 设置字体大小
		myLabel.Font = new Font("宋体", 12); 
		// 命名空间
		using System.Drawing;

		// 设置字体颜色
	    myLabel.Color = CogColorConstants.Red;
	
 
		// 保留小数
	    myLabel.SetXYText(200,200,item.Score.ToString("F3"));
```

#### 2.CogGraphicCollection（图形结合）

​		**`CogGraphicCollection`：** 这是 Cognex VisionPro 库中的一个类，用于表示图形对象的集合。`CogGraphicCollection` 可以包含多个图形对象，这些对象可以是用于机器视觉应用的图形元素，例如区域、线条、点等。

```C#
	 	CogGraphicCollection gcList= new CogGraphicCollection();

		// ICogGraphic类型
		foreach(ICogGraphic item in gcList) {
			mToolBlock.AddGraphicToRunRecord(item, lastRecord, "CogPMAlignTool1.InputImage", "");
        }
```

#### 3.泛型集合

```C#
		using System.Collections.Generic;  // 引入命名空间
		List<CogGraphicLabel>  labelList = new List<CogGraphicLabel>();
```

#### 4.Blob

```C#
        using System;
        using Cognex.VisionPro;
        using Cognex.VisionPro.ToolGroup;
        using System.Drawing;
        using Cognex.VisionPro.Blob;  

		CogGraphicCollection gcList = new CogGraphicCollection();

		// 修改框选Blob区域的颜色
		gcList.Clear();
        CogBlobTool blobTool = toolGroup.Tools["CogBlobTool1"] as CogBlobTool;
        foreach(CogBlobResult item in blobTool.Results.GetBlobs()){
          CogPolygon pg = item.GetBoundary();
          pg.Color = CogColorConstants.Red;
          gcList.Add(pg);
        }

		//输出到图片上
        foreach(CogPolygon item in gcList){
          toolGroup.AddGraphicToRunRecord(item, lastRecord, "Image Source.OutputImage", "");  
        }
```

​		b.GetBoundingBox(CogBlobAxisConstants.Principal)获取的是Blob中每一个结果的最小外接矩形的边框，它是一个CogRectangleAffine类型的对象，包含了位置、大小和旋转角度等信息。您可以使用rect.CenterX, rect.CenterY, rect.Width, rect.Height, rect.Rotation等属性来访问这些信息。

```C#
        foreach( CogBlobResult b in blob.Results.GetBlobs() ) {
              CogRectangleAffine rect = new CogRectangleAffine();
              rect = b.GetBoundingBox(CogBlobAxisConstants.Principal);//最小外接矩形

              //针脚 弯曲的判断
              double angle = Math.Abs(CogMisc.RadToDeg(b.Angle));
              if(Math.Abs(angle - 90) > 5)
              {
                gc.Add(rect);//添加到图形集合
                flag = false;
         }     
        }
```



#### 5.CogCompositeColorMatchTool（颜色匹配）

```c#
		// 命名空间引入
		using Cognex.VisionPro.CompositeColorMatch;

        // 获取颜色匹配工具的范围
        CogRectangleAffine region = matchTool.Region as CogRectangleAffine;

        // 运行颜色匹配工具
        mToolBlock.RunTool(matchTool, ref message, ref result);

        // 获取颜色匹配的最佳结果
        string color = matchTool.Result.ResultOfBestMatch.Color.Name;
```

#### 6.CogToolBlock

```C#
        // 添加颜色输出

        // 工具设置页添加输出，添加特定值
        int count = (int)mToolBlock.Inputs["Count"].value;
```

#### 7.图像预处理

1.CoglmageConvertTool使用方法:彩色图像转换成黑白图像 

2.CoglPOnelmageTool使用方法:常见图像预处理操作 加/减常数、乘以常数、卷积、中值滤波、形态学操作 

3.CogPixelMapTool使用方法:像素映射 

4.CogPolarUnwrapTool使用方法:极性展开工具 

5.CogSobelEdgeTool使用方法:边缘提取工具 

6.CogSurfaceFXTool使用方法:表面瑕疵检测

#### 8.CogPolygon （描边）

```C#
         CogPolygon  polygon = new CogPolygon();
         polygon = blob.Results.GetBlobs()[i].GetBoundary();
```

